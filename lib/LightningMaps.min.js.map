{"version":3,"sources":["webpack://LightningMaps/webpack/universalModuleDefinition","webpack://LightningMaps/webpack/bootstrap","webpack://LightningMaps/./src/TileConversion.js","webpack://LightningMaps/./src/defaultOptions.js","webpack://LightningMaps/./src/index.js","webpack://LightningMaps/./src/Map.js","webpack://LightningMaps/./src/TileLayer.js","webpack://LightningMaps/./src/Tile.js","webpack://LightningMaps/./src/MapState.js","webpack://LightningMaps/./src/Marker.js","webpack://LightningMaps/./src/Polygon.js","webpack://LightningMaps/./node_modules/d3-geo/src/adder.js","webpack://LightningMaps/./node_modules/d3-geo/src/math.js","webpack://LightningMaps/./node_modules/d3-geo/src/noop.js","webpack://LightningMaps/./node_modules/d3-geo/src/stream.js","webpack://LightningMaps/./node_modules/d3-geo/src/area.js","webpack://LightningMaps/./node_modules/d3-geo/src/cartesian.js","webpack://LightningMaps/./node_modules/d3-geo/src/bounds.js","webpack://LightningMaps/./node_modules/d3-geo/src/centroid.js","webpack://LightningMaps/./node_modules/d3-geo/src/constant.js","webpack://LightningMaps/./node_modules/d3-geo/src/compose.js","webpack://LightningMaps/./node_modules/d3-geo/src/rotation.js","webpack://LightningMaps/./node_modules/d3-geo/src/circle.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/buffer.js","webpack://LightningMaps/./node_modules/d3-geo/src/pointEqual.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/rejoin.js","webpack://LightningMaps/./node_modules/d3-geo/src/polygonContains.js","webpack://LightningMaps/./node_modules/d3-array/src/ascending.js","webpack://LightningMaps/./node_modules/d3-array/src/bisect.js","webpack://LightningMaps/./node_modules/d3-array/src/bisector.js","webpack://LightningMaps/./node_modules/d3-array/src/cross.js","webpack://LightningMaps/./node_modules/d3-array/src/array.js","webpack://LightningMaps/./node_modules/d3-array/src/range.js","webpack://LightningMaps/./node_modules/d3-array/src/ticks.js","webpack://LightningMaps/./node_modules/d3-array/src/threshold/sturges.js","webpack://LightningMaps/./node_modules/d3-array/src/merge.js","webpack://LightningMaps/./node_modules/d3-array/src/zip.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/index.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/antimeridian.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/circle.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/line.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/rectangle.js","webpack://LightningMaps/./node_modules/d3-geo/src/clip/extent.js","webpack://LightningMaps/./node_modules/d3-geo/src/length.js","webpack://LightningMaps/./node_modules/d3-geo/src/distance.js","webpack://LightningMaps/./node_modules/d3-geo/src/contains.js","webpack://LightningMaps/./node_modules/d3-geo/src/graticule.js","webpack://LightningMaps/./node_modules/d3-geo/src/interpolate.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/area.js","webpack://LightningMaps/./node_modules/d3-geo/src/identity.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/bounds.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/centroid.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/context.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/measure.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/string.js","webpack://LightningMaps/./node_modules/d3-geo/src/path/index.js","webpack://LightningMaps/./node_modules/d3-geo/src/transform.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/fit.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/resample.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/index.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/conic.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/conicEqualArea.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/cylindricalEqualArea.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/albers.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/albersUsa.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/azimuthal.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/azimuthalEqualArea.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/azimuthalEquidistant.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/mercator.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/conicConformal.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/equirectangular.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/conicEquidistant.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/equalEarth.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/gnomonic.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/identity.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/naturalEarth1.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/orthographic.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/stereographic.js","webpack://LightningMaps/./node_modules/d3-geo/src/projection/transverseMercator.js","webpack://LightningMaps/./node_modules/d3-geo/src/index.js","webpack://LightningMaps/./node_modules/topojson-client/src/identity.js","webpack://LightningMaps/./node_modules/topojson-client/src/transform.js","webpack://LightningMaps/./node_modules/topojson-client/src/bbox.js","webpack://LightningMaps/./node_modules/topojson-client/src/reverse.js","webpack://LightningMaps/./node_modules/topojson-client/src/feature.js","webpack://LightningMaps/./node_modules/topojson-client/src/stitch.js","webpack://LightningMaps/./node_modules/topojson-client/src/mesh.js","webpack://LightningMaps/./node_modules/topojson-client/src/merge.js","webpack://LightningMaps/./node_modules/topojson-client/src/bisect.js","webpack://LightningMaps/./node_modules/topojson-client/src/neighbors.js","webpack://LightningMaps/./node_modules/topojson-client/src/untransform.js","webpack://LightningMaps/./node_modules/topojson-client/src/quantize.js","webpack://LightningMaps/./node_modules/topojson-client/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TileConversion","lon","zoom","rounded","arguments","length","undefined","tile","Math","pow","floor","lat","log","tan","PI","cos","x","z","y","atan","exp","ne","tile2lat","tile2lon","sw","pixel","center","tileSize","pointDiff","tileX","lon2tile","tileY","lat2tile","coord","mapDimensions","source","concat","attribution","panAccelerationMultiplier","maxPanAcceleration","throwTimingThresholdMs","throwVelocityThreshold","animationDurationMs","debounceIntervalMs","tileAreaMultiplier","debug","color","type","_Map","_interopRequireDefault","_Marker","_Polygon","Map","default","Marker","Polygon","_TileConversion","_TileLayer","_MapState","_defaultOptions","canvas","options","_classCallCheck","this","getContext","Error","context","assign","defaultMapOptions","initializeState","attachEvents","applyStyles","lastDrawState","draw","requestAnimationFrame","state","canvasDimensions","width","height","tiles","moveOffset","targetMoveOffset","targetMoveOffsetIsCoord","moveAnimationStart","dragStartPosition","lastEventActionTime","startZoom","targetZoom","zoomAnimationStart","scale","lastMouseMoveEvent","mouseVelocities","markers","polygons","tileLayers","zoomValueIsValid","push","performance","now","Array","isArray","map","parseFloat","pixelToLatLon","position1","position2","time1","time2","_this","addEventListener","event","preventDefault","isReadyForEvent","deltaY","setZoom","centerX","centerY","setTargetMoveOffset","clientX","clientY","timingThreshold","thresholdsToConsider","filter","threshold","averageVelocity","reduce","accumulator","velocity","multiplier","min","updateCenter","vx","calculateVelocity","vy","round","sqrt","style","cursor","time","timestamp","progress","max","percentage","easeOutQuad","latLonToPixel","latLon","differenceFromTarget","abs","newZoomDiff","remainingTime","roundedZoom","diff","shift","tilesZoomLevel","_this2","allTiles","values","maxTilesToKeep","tileExpirationCutOff","Date","getTime","tilesToConsider","lastRequested","sort","a","b","tilesToDeleteCount","splice","forEach","src","tileId","drawState","JSON","stringify","updateMoveOffset","updateZoom","tileLayer","calculateGrid","garbageCollect","shouldRedraw","drawTiles","drawMarkers","drawPolygons","drawAttribution","nw","se","_this3","bounds","getMapBounds","visibleMarkers","marker","coords","position","render","_this4","mapState","polygon","font","textBounds","measureText","fillStyle","roundedRectangle","fillText","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","_this5","addMarker","_Tile","TileLayer","shouldBeDeleted","grid","gridHash","relativeTileOffset","loadedPercentage","canvasSize","tilesCount","ceil","_this$map","join","horizontalTiles","getTilesCount","verticalTiles","centerYRounded","centerXRounded","startX","startY","ensureTileAsset","id","tileUrl","Image","loaded","onload","canvasWidth","canvasHeight","centerOffset","fillRect","horizontalOverflow","verticalOverflow","drawImage","drawGenericBackground","err","strokeStyle","strokeRect","arc","size","increment","lineX","lineY","stroke","totalTiles","loadedTiles","Tile","_x","_y","_zoom","MapState","_center","_tileSize","_canvasDimensions","_moveOffset","_coords","_options","defaultMarkerOptions","renderFunction","renderMarker","renderCircle","renderDonut","save","restore","lineWidth","markerWidth","transform","bezierCurveTo","_d3Geo","_topojsonClient","POLYGON_CACHE","sourceUrl","_sourceUrl","defaultPolygonOptions","_geometry","fetch","then","response","json","catch","console","message","geoTransform","point","projectPoint","path","geoPath","mesh","cacheKey","cachedPosition","projectedX","projectedY","stream","adder","Adder","reset","constructor","add","temp","valueOf","bv","av","epsilon","pi","halfPi","quarterPi","tau","degrees","radians","atan2","sin","math_sign","sign","acos","asin","haversin","noop","streamGeometry","geometry","streamGeometryType","streamObjectType","Feature","FeatureCollection","features","Sphere","sphere","Point","coordinates","MultiPoint","LineString","streamLine","MultiLineString","streamPolygon","MultiPolygon","GeometryCollection","geometries","closed","coordinate","lineStart","lineEnd","polygonStart","polygonEnd","area_lambda00","phi00","area_lambda0","area_cosPhi0","area_sinPhi0","src_stream","areaRingSum","areaSum","areaStream","areaRingStart","areaRingEnd","areaRing","areaPointFirst","areaPoint","lambda","phi","dLambda","sdLambda","adLambda","cosPhi","sinPhi","k","u","v","src_area","cartesian_spherical","cartesian","cartesian_cartesian","spherical","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","bounds_lambda0","bounds_phi0","bounds_lambda1","bounds_phi1","bounds_lambda2","bounds_lambda00","bounds_phi00","bounds_p0","ranges","range","deltaSum","boundsStream","boundsPoint","boundsLineStart","boundsLineEnd","boundsRingPoint","boundsRingStart","boundsRingEnd","bounds_linePoint","normal","inflection","phii","delta","lambdai","antimeridian","bounds_angle","lambda0","lambda1","rangeCompare","rangeContains","W0","W1","centroid_X0","centroid_Y0","Z0","centroid_X1","centroid_Y1","Z1","X2","Y2","Z2","centroid_lambda00","centroid_phi00","centroid_x0","centroid_y0","z0","feature","merged","deltaMax","Infinity","NaN","centroidStream","centroidPoint","centroidLineStart","centroidLineEnd","centroidRingStart","centroidRingEnd","centroidPointCartesian","centroidLinePointFirst","centroidLinePoint","w","centroidRingPointFirst","centroidRingPoint","cx","cy","cz","centroid","constant","compose","invert","rotationIdentity","rotateRadians","deltaLambda","deltaPhi","deltaGamma","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","src_rotation","rotate","forward","circleStream","radius","direction","t0","t1","cosRadius","sinRadius","step","circleRadius","src_circle","ring","precision","circle","apply","_","buffer","line","lines","rejoin","pop","result","pointEqual","Intersection","points","other","entry","e","segments","compareIntersection","startInside","interpolate","subject","clip","segment","p0","p1","rejoin_link","start","current","isSubject","array","polygonContains_sum","polygonContains","angle","winding","point0","phi0","sinPhi0","cosPhi0","j","sinPhi1","cosPhi1","point1","phi1","absDelta","intersection","phiArc","ascending","ascendingBisect","compare","f","ascendingComparator","left","lo","hi","mid","right","bisector","array_array","src_range","slice","stop","merge","arrays","src_clip","pointVisible","clipLine","sink","ringBuffer","ringSink","polygonStarted","pointRing","ringStart","ringEnd","clip_compareIntersection","pointLine","clean","ringSegments","validSegment","clip_antimeridian","sign0","sign1","sinLambda0Lambda1","clipAntimeridianIntersect","from","to","clip_circle","cr","smallRadius","notHemisphere","visible","intersect","two","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","uu","t2","q","polar","q1","code","c0","v0","v00","point2","clip_line","x0","y0","x1","y1","ax","ay","dx","dy","clipMax","clipMin","clipRectangle","a1","corner","comparePoint","ca","cb","x__","y__","v__","x_","y_","v_","first","activeStream","bufferStream","clipStream","linePoint","a0","b0","b1","polygonInside","cleanInside","length_lambda0","length_sinPhi0","length_cosPhi0","clip_extent","cache","cacheStream","extent","lengthSum","lengthStream","lengthPointFirst","lengthLineEnd","lengthPoint","cosDelta","src_length","distance_coordinates","distance_object","distance","containsObjectType","containsGeometry","containsGeometryType","containsPoint","containsLine","containsPolygon","ab","ringRadians","pointRadians","contains","graticuleX","graticuleY","graticule_graticule","X1","X0","Y1","Y0","X","Y","DX","DY","graticule","outline","reverse","extentMajor","extentMinor","stepMajor","stepMinor","graticule10","area_x00","area_y00","area_x0","area_y0","src_interpolate","cy0","sy0","cy1","sy1","kx0","ky0","kx1","ky1","B","src_identity","area_areaSum","area_areaRingSum","area_areaStream","area_areaRingStart","area_areaRingEnd","area","area_areaPointFirst","area_areaPoint","path_area","bounds_x0","bounds_y0","bounds_x1","bounds_y1","centroid_x00","centroid_y00","path_centroid_x0","path_centroid_y0","path_bounds","path_centroid_X0","path_centroid_Y0","centroid_Z0","path_centroid_X1","path_centroid_Y1","centroid_Z1","centroid_X2","centroid_Y2","centroid_Z2","centroid_centroidStream","centroid_centroidPoint","centroid_centroidLineStart","centroid_centroidLineEnd","centroid_centroidRingStart","centroid_centroidRingEnd","centroidPointFirstLine","centroidPointLine","centroidPointFirstRing","centroidPointRing","path_centroid","PathContext","_context","_radius","pointRadius","_line","_point","lengthRing","measure_x00","measure_y00","measure_x0","measure_y0","measure_lengthSum","measure_lengthStream","measure_lengthPointFirst","measure_lengthPoint","measure","PathString","_string","string_circle","_circle","src_path","projection","projectionStream","contextStream","src_transform","methods","transformer","TransformStream","fit","fitBounds","clipExtent","translate","fitExtent","h","fitSize","fitWidth","fitHeight","maxDepth","cosMinDistance","resample","project","delta2","resampleLineTo","depth","d2","phi2","lambda2","x2","y2","dx2","dy2","dz","lambda00","x00","y00","a00","b00","c00","resampleStream","ringPoint","resample_resample","resampleNone","transformRadians","scaleTranslateRotate","alpha","cosAlpha","sinAlpha","ai","bi","ci","fi","projection_projection","projectionMutator","projectAt","projectResample","projectTransform","projectRotateTransform","theta","preclip","postclip","recenter","transformRotate","clipAngle","conicProjection","parallels","conicEqualAreaRaw","cylindricalEqualAreaRaw","r0","r0y","conicEqualArea","albers","projection_albersUsa","lower48Point","alaskaPoint","hawaiiPoint","lower48","alaska","hawaii","pointStream","albersUsa","streams","multiplex","azimuthalRaw","azimuthalInvert","sc","cc","azimuthalEqualAreaRaw","cxcy","azimuthalEqualArea","azimuthalEquidistantRaw","azimuthalEquidistant","mercatorRaw","mercator","mercatorProjection","reclip","tany","conicConformalRaw","fy","conicConformal","equirectangularRaw","equirectangular","conicEquidistantRaw","g","gy","nx","conicEquidistant","A1","A2","A3","A4","M","equalEarthRaw","l2","l6","equalEarth","gnomonicRaw","gnomonic","identity_scaleTranslate","kx","ky","tx","ty","projection_identity","sx","sy","reflectX","reflectY","naturalEarth1Raw","phi4","naturalEarth1","orthographicRaw","orthographic","stereographicRaw","stereographic","transverseMercatorRaw","transverseMercator","__webpack_exports__","identity","input","output","bbox","topology","bboxPoint","bboxGeometry","arcs","objects","feature_feature","properties","feature_object","transformPoint","stitch","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","flush","end","dp","ends","fg","unshift","gf","meshArcs","geom","geomsByArc","extract0","extract1","extract2","extract3","geoms","extractArcs","mergeArcs","polygonsByArc","groups","extract","planarRingArea","group","neighbors","ki","bisect","src_neighbors","indexesByArc","geometryType","indexes","ij","ik","untransform","quantize","box","inputs","outputs","quantizePoint","quantizeGeometry"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,mBAAAH,GACA,iBAAAC,QACAA,QAAA,cAAAD,IAEAD,EAAA,cAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,8QCjFqBC,6NACHC,EAAKC,GAAsB,IAAhBC,IAAgBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACnCG,GAAQN,EAAM,KAAO,IAAMO,KAAKC,IAAI,EAAGP,GAE7C,OAAOC,EACHK,KAAKE,MAAMH,GACXA,mCAGUI,EAAKT,GAAsB,IAAhBC,IAAgBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACnCG,GAAQ,EAAIC,KAAKI,IAAIJ,KAAKK,IAAIF,EAAMH,KAAKM,GAAK,KAAO,EAAIN,KAAKO,IAAIJ,EAAMH,KAAKM,GAAK,MACpFN,KAAKM,IAAM,EAAIN,KAAKC,IAAI,EAAGP,GAE/B,OAAOC,EACHK,KAAKE,MAAMH,GACXA,mCAGUS,EAAGC,GACjB,OAAOD,EAAIR,KAAKC,IAAI,EAAGQ,GAAK,IAAM,qCAGpBC,EAAGD,GACjB,IAAMxB,EAAIe,KAAKM,GAAK,EAAIN,KAAKM,GAAKI,EAAIV,KAAKC,IAAI,EAAGQ,GAElD,OAAO,IAAMT,KAAKM,GAAKN,KAAKW,KAAK,IAAOX,KAAKY,IAAI3B,GAAKe,KAAKY,KAAK3B,8CAG1CuB,EAAGE,EAAGhB,GAC5B,OACEmB,IACErB,EAAesB,SAASJ,EAAGhB,GAC3BF,EAAeuB,SAASP,EAAI,EAAGd,IAGjCsB,IACExB,EAAesB,SAASJ,EAAI,EAAGhB,GAC/BF,EAAeuB,SAASP,EAAGd,2CAKZuB,EAAOC,EAAQxB,EAAMyB,GACxC,IAAMC,GACJH,EAAM,GAAKE,EACXF,EAAM,GAAKE,GAGPE,EAAQ7B,EAAe8B,SAASJ,EAAO,GAAIxB,GAAM,GAAS0B,EAAU,GACpEG,EAAQ/B,EAAegC,SAASN,EAAO,GAAIxB,GAAM,GAAS0B,EAAU,GAE1E,OACE5B,EAAesB,SAASS,EAAO7B,GAC/BF,EAAeuB,SAASM,EAAO3B,0CAId+B,EAAOP,EAAQxB,EAAMyB,EAAUO,GAClD,IAAML,EAAQ7B,EAAe8B,SAASG,EAAM,GAAI/B,GAAM,GAChD6B,EAAQ/B,EAAegC,SAASC,EAAM,GAAI/B,GAAM,GAKtD,SACI2B,EAJgB7B,EAAe8B,SAASJ,EAAO,GAAIxB,GAAM,IAIlCyB,IACvBI,EAJgB/B,EAAegC,SAASN,EAAO,GAAIxB,GAAM,IAIlCyB,0NC/D7BQ,OAAQ,SAACnB,EAAGE,EAAGD,GAAP,2CAAAmB,OAAkDnB,EAAlD,KAAAmB,OAAuDpB,EAAvD,KAAAoB,OAA4DlB,EAA5D,SACRhB,KAAM,GACNwB,QAAS,WAAY,WACrBW,YAAa,+BAKbV,SAAU,IAMVW,0BAA2B,EAM3BC,mBAAoB,IAMpBC,uBAAwB,IAMxBC,uBAAwB,IAKxBC,oBAAqB,IAKrBC,mBAAoB,IAQpBC,mBAAoB,EAMpBC,OAAO,2BAQPC,MAAO,uBAKPC,KAAM,mCAQND,MAAO,wHCjFT,IAAAE,EAAAC,EAAAnF,EAAA,IACAoF,EAAAD,EAAAnF,EAAA,IACAqF,EAAAF,EAAAnF,EAAA,8DAGEsF,IAAGJ,EAAAK,QACHC,OAAMJ,EAAAG,QACNE,QAAOJ,EAAAE,yICPT,IAAAG,EAAAP,EAAAnF,EAAA,IACA2F,EAAAR,EAAAnF,EAAA,IACA4F,EAAAT,EAAAnF,EAAA,IACA6F,EAAA7F,EAAA,gOAEqBsF,aAEnB,SAAAA,EAAYQ,EAAQC,GAClB,+FAD2BC,CAAAC,KAAAX,IACtBQ,IAAWA,EAAOI,WACrB,MAAM,IAAIC,MAAM,gCAGlBF,KAAKH,OAASA,EACdG,KAAKG,QAAUH,KAAKH,OAAOI,WAAW,MAEtCD,KAAKF,QAAUnF,OAAOyF,UAAPR,EAAAS,kBAAqCP,GAEpDE,KAAKM,kBACLN,KAAKO,eACLP,KAAKQ,cAELR,KAAKS,cAAgB,KAErBT,KAAKU,KAAOV,KAAKU,KAAKjF,KAAKuE,MAC3BnG,OAAO8G,sBAAsBX,KAAKU,uGAIlCV,KAAKY,OACHC,kBAAmBb,KAAKH,OAAOiB,MAAOd,KAAKH,OAAOkB,QAClDC,SACAC,YAAa,EAAG,GAChBC,kBAAmB,EAAG,GACtBC,yBAAyB,EACzBC,mBAAoB,KACpBC,kBAAmB,KACnBC,oBAAqB,KACrBC,UAAWvB,KAAKF,QAAQ3D,KACxBqF,WAAYxB,KAAKF,QAAQ3D,KACzBsF,mBAAoB,KACpBC,MAAO,EACPC,mBAAoB,KACpBC,mBACAC,WACAC,YACAC,YACE,IAAArC,EAAAJ,QAAcU,0CAMlB,OAAOA,KAAKF,QAAQ3D,qCAGdA,GACF6D,KAAKgC,iBAAiB7F,KACxB6D,KAAKY,MAAMmB,WAAWE,KAAK,IAAAvC,EAAAJ,QAAcU,KAAM7D,IAG/C6D,KAAKY,MAAMU,oBAAsBzH,OAAOqI,YAAYC,MACpDnC,KAAKY,MAAMa,mBAAqB5H,OAAOqI,YAAYC,MACnDnC,KAAKY,MAAMY,WAAarF,EACxB6D,KAAKY,MAAMW,UAAYvB,KAAKF,QAAQ3D,wCAI9B+B,GACR,IAAKkE,MAAMC,QAAQnE,IAA2B,IAAjBA,EAAM5B,OACjC,MAAM,IAAI4D,MAAM,+CAGlBhC,EAAQA,EAAMoE,IAAI,SAAApE,GAAK,OAAIqE,WAAWrE,KAEtC8B,KAAKY,MAAMQ,mBAAqBvH,OAAOqI,YAAYC,MACnDnC,KAAKY,MAAMM,iBAAmBhD,EAC9B8B,KAAKY,MAAMO,yBAA0B,8CAGnBlE,EAAGE,KAAoBd,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,IAEvC2D,KAAKY,MAAMQ,mBAAqBvH,OAAOqI,YAAYC,MAEnDnC,KAAKY,MAAMM,iBAAmBzB,EAAAH,QAAekD,eAC1CvF,EAAGE,GACJ6C,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,UAGfoC,KAAKY,MAAMO,yBAA0B,IAErCnB,KAAKY,MAAMM,kBAAoBjE,EAAGE,GAClC6C,KAAKY,MAAMO,yBAA0B,EAErCnB,KAAKY,MAAMK,WAAajB,KAAKY,MAAMM,2DAItB/E,GACf,OAAOA,GAAQ,GAAKA,GAAQ,6CAI5B,OAAK6D,KAAKY,MAAMU,qBAIJzH,OAAOqI,YAAYC,MACUnC,KAAKY,MAAMU,oBAEhBtB,KAAKF,QAAQlB,6DAGjC6D,EAAWC,EAAWC,EAAOC,GAC7C,OAASH,EAAYC,IAAcC,EAAQC,GAAU,2CAGxC,IAAAC,EAAA7C,KACbA,KAAKH,OAAOiD,iBAAiB,QAAS,SAAAC,GACpCA,EAAMC,iBAEFH,EAAKI,oBACHF,EAAMG,OAAS,EACjBL,EAAKM,QAAQN,EAAK/C,QAAQ3D,KAAO,GACxB4G,EAAMG,QAAU,GACzBL,EAAKM,QAAQN,EAAK/C,QAAQ3D,KAAO,MAKvC6D,KAAKH,OAAOiD,iBAAiB,WAAY,SAAAC,GACvCA,EAAMC,iBAEN,IAAMI,EAAUP,EAAKjC,MAAMC,iBAAiB,GAAK,EAC3CwC,EAAUR,EAAKjC,MAAMC,iBAAiB,GAAK,EAEjDgC,EAAKS,sBACDP,EAAMQ,QAAUH,KAChBL,EAAMS,QAAUH,IAGpBR,EAAKM,QAAQN,EAAK/C,QAAQ3D,KAAO,KAGnC6D,KAAKH,OAAOiD,iBAAiB,YAAa,SAAAC,GACxCA,EAAMC,iBAENH,EAAKjC,MAAMgB,mBAEXiB,EAAKjC,MAAMS,mBACT0B,EAAMQ,QAAUV,EAAKjC,MAAMK,WAAW,GACtC8B,EAAMS,QAAUX,EAAKjC,MAAMK,WAAW,MAI1CjB,KAAKH,OAAOiD,iBAAiB,UAAW,SAAAC,GACtCA,EAAMC,iBAEN,IAAM/F,IAAM4F,EAAKjC,MAAMS,kBAAkB,GAAK0B,EAAMQ,SAC9CpG,IAAM0F,EAAKjC,MAAMS,kBAAkB,GAAK0B,EAAMS,SAEpD,GAAiC,IAA7BX,EAAKjC,MAAMK,WAAW,IAAyC,IAA7B4B,EAAKjC,MAAMK,WAAW,GAAU,CACpE,IACMwC,EADM5J,OAAOqI,YAAYC,MACDU,EAAK/C,QAAQrB,uBAErCiF,EAAuBb,EAAKjC,MAAMgB,gBACrC+B,OAAO,SAAAC,GAAS,OAAIA,EAAU,GAAKH,IACnCnB,IAAI,SAAAsB,GAAS,OAAIA,EAAU,KAOxBC,EALcH,EAAqBI,OACvC,SAACC,EAAaC,GAAd,OAA2BD,EAAcC,GACzC,GAGoCN,EAAqBpH,OAE3D,GAAIuH,GAAmBhB,EAAK/C,QAAQpB,uBAAwB,CAC1D,IAAIuF,EAAaJ,EAAkBhB,EAAK/C,QAAQpB,uBAC5CmE,EAAK/C,QAAQvB,0BAEjB0F,EAAaxH,KAAKyH,IAAID,EAAYpB,EAAK/C,QAAQtB,oBAE/CqE,EAAKS,oBACHrG,EAAIgH,EACJ9G,EAAI8G,QAGNpB,EAAKsB,eAITtB,EAAKjC,MAAMS,kBAAoB,OAGjCrB,KAAKH,OAAOiD,iBAAiB,YAAa,SAAAC,GAGxC,GAFAA,EAAMC,iBAEFH,EAAKjC,MAAMS,kBAAmB,CAChC,IAAMpE,IAAM4F,EAAKjC,MAAMS,kBAAkB,GAAK0B,EAAMQ,SAC9CpG,IAAM0F,EAAKjC,MAAMS,kBAAkB,GAAK0B,EAAMS,SAE9CrB,EAAMtI,OAAOqI,YAAYC,MAEzBiC,EAAKvB,EAAKwB,kBAAkBxB,EAAKjC,MAAMK,WAAW,GAAIhE,EAAGkF,EAAKU,EAAKjC,MAAMe,oBACzE2C,EAAKzB,EAAKwB,kBAAkBxB,EAAKjC,MAAMK,WAAW,GAAI9D,EAAGgF,EAAKU,EAAKjC,MAAMe,oBAEzEqC,EAAWvH,KAAK8H,MAAM9H,KAAK+H,KAAMJ,EAAKA,EAAOE,EAAKA,IAExDzB,EAAKjC,MAAMgB,gBAAgBK,MAAME,EAAK6B,IAEtCnB,EAAKS,oBAAoBrG,EAAGE,GAAG,GAC/B0F,EAAKjC,MAAMe,mBAAqB9H,OAAOqI,YAAYC,MAGrD,OAAO,0CAKTnC,KAAKH,OAAO4E,MAAMC,OAAS,2CAGjBC,GACV,OAAOA,GAAQ,EAAIA,8CAMnB,GAFgC3E,KAAKY,MAAMK,aAAejB,KAAKY,MAAMM,iBAExC,CAC3B,IAAM0D,EAAY/K,OAAOqI,YAAYC,MAE/B0C,EAAWpI,KAAKqI,IAAIF,EAAY5E,KAAKY,MAAMQ,mBAAoB,GAC/D2D,EAAa/E,KAAKgF,YAAYH,EAAW7E,KAAKF,QAAQnB,qBAExDuC,EAAmBlB,KAAKY,MAAMM,iBAE9BlB,KAAKY,MAAMO,0BACbD,EAAmBzB,EAAAH,QAAe2F,cAChCjF,KAAKY,MAAMM,iBACXlB,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,SACboC,KAAKY,MAAMC,mBAKbb,KAAKY,MAAMK,WADT8D,GAAc,IACQ7D,GAGtBlB,KAAKY,MAAMK,WAAW,IAAMC,EAAiB,GAAKlB,KAAKY,MAAMK,WAAW,IAAM8D,EAC9E/E,KAAKY,MAAMK,WAAW,IAAMC,EAAiB,GAAKlB,KAAKY,MAAMK,WAAW,IAAM8D,GAIrD/E,KAAKY,MAAMK,aAAeC,GAGrDlB,KAAKmE,uDAMT,IAAMe,EAASzF,EAAAH,QAAekD,cAC5BxC,KAAKY,MAAMK,WACXjB,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,UAGfoC,KAAKsD,oBAAoB,EAAG,GAAG,GAC/BtD,KAAKF,QAAQnC,OAASuH,uCAItB,GAAIlF,KAAKF,QAAQ3D,OAAS6D,KAAKY,MAAMY,WAAY,CAC/C,IAAMqD,EAAWpI,KAAKqI,IAAIjL,OAAOqI,YAAYC,MAAQnC,KAAKY,MAAMa,mBAAoB,GAC9EsD,EAAa/E,KAAKgF,YAAYH,EAAW7E,KAAKF,QAAQnB,qBAExDwG,EAAuB1I,KAAK2I,IAAIpF,KAAKY,MAAMY,WAAaxB,KAAKY,MAAMW,WAEnEvB,KAAKY,MAAMY,YAAcxB,KAAKY,MAAMW,YACtC4D,IAAyB,GAG3B,IAAME,EAAcF,EAAuBJ,EACrCO,EAAgBtF,KAAKF,QAAQnB,oBAAsBkG,EAEzD7E,KAAKF,QAAQ3D,KAAOmJ,GAAiB,EACjCtF,KAAKY,MAAMY,WACVxB,KAAKY,MAAMW,UAAY8D,EAE5B,IAAME,EAAc9I,KAAK8H,MAAMvE,KAAKF,QAAQ3D,MACtCqJ,EAAOxF,KAAKF,QAAQ3D,KAAOoJ,EAEjCvF,KAAKY,MAAMc,MAAQjF,KAAKC,IAAI,EAAG8I,GAE3BxF,KAAKF,QAAQ3D,OAAS6D,KAAKY,MAAMY,aAEnCxB,KAAKY,MAAMmB,WAAW0D,QACtBzF,KAAKY,MAAMmB,WAAW,GAAG2D,eAAiB,WAK5C1F,KAAKY,MAAMc,MAAQ,2CAIN,IAAAiE,EAAA3F,KACT4F,EAAWjL,OAAOkL,OAAO7F,KAAKY,MAAMI,OAE1C,GAAI4E,EAAStJ,OAAS0D,KAAK8F,iBAAkB,CAC3C,IAAMC,GAAuB,IAAIC,MAAOC,UAAY,IAE9CC,EAAkBN,EACrBjC,OAAO,SAAAnH,GAAI,OAAIA,EAAK2J,cAAgBJ,IACpCK,KAAK,SAACC,EAAGC,GAAJ,SAAaD,EAAEF,cAAgBG,EAAEH,iBAEnCI,EAAqBvG,KAAK8F,kBAAoBF,EAAStJ,OAAS4J,EAAgB5J,QAEtF4J,EACGM,OAAON,EAAgB5J,OAASiK,GAChCE,QAAQ,SAAAjK,GACPA,EAAKkK,IAAM,UACJf,EAAK/E,MAAMI,MAAMxE,EAAKmK,oDAMnC,OAAO,2CAIP,IAAMC,EAAYC,KAAKC,WAAW9G,KAAKY,MAAOZ,KAAKF,UAEnD,OAAIE,KAAKS,gBAAkBmG,IACzB5G,KAAKS,cAAgBmG,GAEd,kCAOT5G,KAAK+G,mBACL/G,KAAKgH,aACLhH,KAAKY,MAAMmB,WAAW0E,QAAQ,SAAAQ,GAAS,OAAIA,EAAUC,kBACrDlH,KAAKmH,iBAEDnH,KAAKoH,iBASHpH,KAAKY,MAAMmB,WAAWzF,OAAS,GAEjC0D,KAAKY,MAAMmB,WAAW,GAAGsF,UAAUrH,KAAKY,MAAMc,OAGhD1B,KAAKsH,cACLtH,KAAKuH,eACLvH,KAAKwH,mBAGP3N,OAAO8G,sBAAsBX,KAAKU,6CAkBlC,OACE+G,GAfShI,EAAAH,QAAekD,eACvBxC,KAAKY,MAAMC,iBAAiB,GAAK,EAAIb,KAAKY,MAAMC,iBAAiB,GAAK,GACvEb,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,UAWT8J,GARKjI,EAAAH,QAAekD,gBACtBxC,KAAKY,MAAMC,iBAAiB,GAAK,GAAKb,KAAKY,MAAMC,iBAAiB,GAAK,GACzEb,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,iDAQH,IAAA+J,EAAA3H,KACN4H,EAAS5H,KAAK6H,eAEdC,EAAiB9H,KAAKY,MAAMiB,QAAQ8B,OAAO,SAAAoE,GAC/C,OAAOA,EAAOC,OAAO,IAAMJ,EAAOH,GAAG,IAAMM,EAAOC,OAAO,IAAMJ,EAAOF,GAAG,IACpEK,EAAOC,OAAO,IAAMJ,EAAOH,GAAG,IAAMM,EAAOC,OAAO,IAAMJ,EAAOF,GAAG,KAGnE/J,GACJqC,KAAKY,MAAMC,iBAAiB,GAAK,EACjCb,KAAKY,MAAMC,iBAAiB,GAAK,GAGnCiH,EAAexF,IAAI,SAAAyF,GACjB,IAAME,EAAWxI,EAAAH,QAAe2F,cAC9B8C,EAAOC,OACPL,EAAK7H,QAAQnC,OACbgK,EAAK7H,QAAQ3D,KACbwL,EAAK7H,QAAQlC,SACb+J,EAAK/G,MAAMC,kBAGbkH,EAAOG,OAAOP,EAAKxH,SACjBxC,EAAO,GAAKsK,EAAS,GAAKN,EAAK/G,MAAMK,WAAW,GAChDtD,EAAO,GAAKsK,EAAS,GAAKN,EAAK/G,MAAMK,WAAW,8CAKvC,IAAAkH,EAAAnI,KACPoI,EAAW,IAAAzI,EAAAL,QACfU,KAAKF,QAAQnC,OACbqC,KAAKF,QAAQ3D,KACb6D,KAAKF,QAAQlC,SACboC,KAAKY,MAAMC,iBACXb,KAAKY,MAAMK,YAGbjB,KAAKY,MAAMkB,SAASQ,IAAI,SAAA+F,GACtBA,EAAQH,OAAOC,EAAKhI,QAASiI,+CAO/BpI,KAAKG,QAAQmI,KAAO,uBACpB,IAAMC,EAAavI,KAAKG,QAAQqI,YAAYxI,KAAKF,QAAQxB,aAEnDrB,EAAI+C,KAAKY,MAAMC,iBAAiB,GAAK0H,EAAWzH,MALvC,EAMT3D,EAAI6C,KAAKY,MAAMC,iBAAiB,GAAK,EAN5B,EAQfb,KAAKG,QAAQsI,UAAY,2BACzBzI,KAAK0I,iBAAiBzL,EATP,EASmBE,EAAI,GAAIoL,EAAWzH,MAAQ,GAAI,IAEjEd,KAAKG,QAAQsI,UAAY,qBACzBzI,KAAKG,QAAQwI,SAAS3I,KAAKF,QAAQxB,YAAarB,EAAGE,4CAIpCF,EAAGE,EAAG2D,EAAOC,GAG5Bf,KAAKG,QAAQyI,YACb5I,KAAKG,QAAQ0I,OAAO5L,EAHL,EAGiBE,GAChC6C,KAAKG,QAAQ2I,OAAO7L,EAAI6D,EAJT,EAIyB3D,GACxC6C,KAAKG,QAAQ4I,iBAAiB9L,EAAI6D,EAAO3D,EAAGF,EAAI6D,EAAO3D,EALxC,GAMf6C,KAAKG,QAAQ2I,OAAO7L,EAAI6D,EAAO3D,EAAI4D,EANpB,GAOff,KAAKG,QAAQ4I,iBAAiB9L,EAAI6D,EAAO3D,EAAI4D,EAAQ9D,EAAI6D,EAP1C,EAO0D3D,EAAI4D,GAC7Ef,KAAKG,QAAQ2I,OAAO7L,EARL,EAQiBE,EAAI4D,GACpCf,KAAKG,QAAQ4I,iBAAiB9L,EAAGE,EAAI4D,EAAQ9D,EAAGE,EAAI4D,EATrC,GAUff,KAAKG,QAAQ2I,OAAO7L,EAAGE,EAVR,GAWf6C,KAAKG,QAAQ4I,iBAAiB9L,EAAGE,EAAGF,EAXrB,EAWiCE,GAChD6C,KAAKG,QAAQ6I,YAEbhJ,KAAKG,QAAQ8I,yCAGLlB,GACR/H,KAAKY,MAAMiB,QAAQI,KAAK8F,sCAGflG,GAAS,IAAAqH,EAAAlJ,KAClB6B,EAAQS,IAAI,SAAAyF,GAAM,OAAImB,EAAKC,UAAUpB,wCAG5BM,GACTrI,KAAKY,MAAMkB,SAASG,KAAKoG,4ICpe7B,IAAA5I,EAAAP,EAAAnF,EAAA,IACAqP,EAAAlK,EAAAnF,EAAA,iOAEqBsP,aAEnB,SAAAA,EAAY/G,GAA4B,IAAvBoD,EAAuBrJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAN,kGAAM0D,CAAAC,KAAAqJ,GACtCrJ,KAAKsC,IAAMA,EACXtC,KAAK0F,eAAiBA,EACtB1F,KAAKsJ,iBAAkB,EAEvBtJ,KAAKG,QAAUmC,EAAInC,QAEnBH,KAAKY,OACH2I,QACAC,SAAU,KACVC,oBAAqB,EAAG,4FAK1B,OACEzJ,KAAKY,MACLZ,KAAK0J,0DAIKC,GACZ,IAAIC,EAAanN,KAAKoN,KAAKF,EAAa3J,KAAKsC,IAAIxC,QAAQlC,UAAYoC,KAAKsC,IAAIxC,QAAQjB,mBAMtF,OAJI+K,EAAa,GAAM,GACrBA,IAGKA,0CAGO,IAAAE,EACa9J,KAAKsC,IAAxB1B,EADMkJ,EACNlJ,MAAOd,EADDgK,EACChK,QAETuD,EAAU5D,EAAAH,QAAerB,SAAS6B,EAAQnC,OAAO,GAAIlB,KAAK8H,MAAMvE,KAAK0F,gBAAkB5F,EAAQ3D,OAAO,GACtGiH,EAAU3D,EAAAH,QAAevB,SAAS+B,EAAQnC,OAAO,GAAIlB,KAAK8H,MAAMvE,KAAK0F,gBAAkB5F,EAAQ3D,OAAO,GACtGqN,GAAYnG,EAASD,GAAS2G,KAAK,KAIzC,GAF6B/J,KAAKY,MAAM4I,WAAaA,EAErD,CAIA,IAAMQ,EAAkBhK,KAAKiK,cAAcrJ,EAAMC,iBAAiB,IAC5DqJ,EAAgBlK,KAAKiK,cAAcrJ,EAAMC,iBAAiB,IAG1DsJ,EAAiB1N,KAAKE,MAAM0G,GAC5B+G,EAAiB3N,KAAKE,MAAMyG,GAElCpD,KAAKY,MAAM6I,oBACThN,KAAK2I,IAAIhC,EAAUgH,GACnB3N,KAAK2I,IAAI/B,EAAU8G,IAQrB,IALA,IAAME,EAASD,EAAiB3N,KAAKE,MAAMqN,EAAkB,GACvDM,EAASH,EAAiB1N,KAAKE,MAAMuN,EAAgB,GAEvDX,KAEKpM,EAAI,EAAGA,EAAI+M,EAAe/M,IACjC,IAAK,IAAIF,EAAI,EAAGA,EAAI+M,EAAiB/M,IAAK,CACnCsM,EAAKtM,KACRsM,EAAKtM,OAGP,IAAMa,EAAQuM,EAASpN,EACjBe,EAAQsM,EAASnN,EAEnBW,GAAS,GAAKE,GAAS,IACzBuL,EAAKtM,GAAGE,GAAK,IAAAiM,EAAA9J,QAASxB,EAAOE,EAAOvB,KAAK8H,MAAMvE,KAAK0F,gBAAkB5F,EAAQ3D,OAC9E6D,KAAKuK,gBAAgBhB,EAAKtM,GAAGE,KAKnC6C,KAAKY,MAAM2I,KAAOA,EAClBvJ,KAAKY,MAAM4I,SAAWA,2CAGRhN,GAAM,IAAAqG,EAAA7C,KACpB,KAAMxD,EAAKgO,MAAMxK,KAAKsC,IAAI1B,MAAMI,OAAQ,CACtC,IAAMyJ,EAAUzK,KAAKsC,IAAIxC,QAAQ1B,OAAO3B,KAAKE,MAAMH,EAAKS,GAAIR,KAAKE,MAAMH,EAAKW,GAAIX,EAAKL,MAErF6D,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAM,IAAIE,MACpC1K,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAI7D,OAASnK,EAAKgO,GAC5CxK,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAI9D,IAAM+D,EACpCzK,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAIG,QAAS,EACvC3K,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAII,OAAS,WACrC/H,EAAKP,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAIG,QAAS,GAI3C3K,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAIrE,eAAgB,IAAIH,MAAOC,4CAGjDvE,GACR,IAAMmJ,EAAc7K,KAAKsC,IAAI1B,MAAMC,iBAAiB,GAC9CiK,EAAe9K,KAAKsC,IAAI1B,MAAMC,iBAAiB,GAE/CjD,EAAWoC,KAAKsC,IAAIxC,QAAQlC,SAAW8D,EAEvCqJ,GACJnN,EAAW,EAAKoC,KAAKY,MAAM6I,mBAAmB,GAAK7L,EACnDA,EAAW,EAAKoC,KAAKY,MAAM6I,mBAAmB,GAAK7L,GAGrDoC,KAAKG,QAAQsI,UAAY,OACzBzI,KAAKG,QAAQ6K,SAAS,EAAG,EAAGH,EAAaC,GAQzC,IANA,IAAMd,EAAkBhK,KAAKiK,cAAcY,GACrCX,EAAgBlK,KAAKiK,cAAca,GAEnCG,EAAsBjB,EAAkBpM,EAAYiN,EACpDK,EAAoBhB,EAAgBtM,EAAYkN,EAE7C3N,EAAI,EAAGA,EAAI+M,EAAe/M,IACjC,IAAK,IAAIF,EAAI,EAAGA,EAAI+M,EAAiB/M,IAAK,CACxC,IAAMT,EAAOwD,KAAKY,MAAM2I,KAAKtM,GAAGE,GAEhC,GAAIX,EAAM,CACR,IAAMsB,EAAQkC,KAAKsC,IAAI1B,MAAMK,WAAW,GAAK8J,EAAa,IACrD9N,EAAIW,EAAWqN,EAAqB,GAEnCjN,EAAQgC,KAAKsC,IAAI1B,MAAMK,WAAW,GAAK8J,EAAa,IACrD5N,EAAIS,EAAWsN,EAAmB,GAEvC,IACMlL,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAIG,OAChC3K,KAAKG,QAAQgL,UAAUnL,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAK1M,EAAOE,EAAOJ,EAAUA,GAE9EoC,KAAKoL,sBAAsBtN,EAAOE,EAAOJ,GAE3C,MAAOyN,GACPrL,KAAKoL,sBAAsBtN,EAAOE,EAAOJ,GAGvCoC,KAAKsC,IAAIxC,QAAQhB,QACnBkB,KAAKG,QAAQmL,YAAc,QAC3BtL,KAAKG,QAAQoL,WAAWzN,EAAOE,EAAOJ,EAAUA,KAMpDoC,KAAKsC,IAAIxC,QAAQhB,QACnBkB,KAAKG,QAAQsI,UAAY,uBACzBzI,KAAKG,QAAQyI,YACb5I,KAAKG,QAAQqL,IAAIX,EAAc,EAAGC,EAAe,EAAG,EAAG,EAAG,EAAIrO,KAAKM,IACnEiD,KAAKG,QAAQ8I,sDAIKhM,EAAGE,EAAGsO,GAC1B,IAAMC,EAAYD,EAAO,EAEzBzL,KAAKG,QAAQyI,YACb,IAAK,IAAI+C,EAAQD,EAAWC,EAAQF,EAAME,GAASD,EACjD,IAAK,IAAIE,EAAQF,EAAWE,EAAQH,EAAMG,GAASF,EACjD1L,KAAKG,QAAQ0I,OAAO5L,EAAGE,EAAIyO,GAC3B5L,KAAKG,QAAQ2I,OAAO7L,EAAIwO,EAAMtO,EAAIyO,GAElC5L,KAAKG,QAAQ0I,OAAO5L,EAAI0O,EAAOxO,GAC/B6C,KAAKG,QAAQ2I,OAAO7L,EAAI0O,EAAOxO,EAAIsO,GAGvCzL,KAAKG,QAAQmL,YAAc,OAC3BtL,KAAKG,QAAQ0L,SAEb7L,KAAKG,QAAQmL,YAAc,OAC3BtL,KAAKG,QAAQoL,WAAWtO,EAAGE,EAAGsO,EAAMA,8CAUpC,IANA,IAAMzB,EAAkBhK,KAAKiK,cAAcjK,KAAKsC,IAAI1B,MAAMC,iBAAiB,IACrEqJ,EAAgBlK,KAAKiK,cAAcjK,KAAKsC,IAAI1B,MAAMC,iBAAiB,IAEnEiL,EAAa9B,EAAkBE,EACjC6B,EAAc,EAET5O,EAAI,EAAGA,EAAI+M,EAAe/M,IACjC,IAAK,IAAIF,EAAI,EAAGA,EAAI+M,EAAiB/M,IAAK,CACxC,IAAMT,EAAOwD,KAAKY,MAAM2I,KAAKtM,GAAGE,GAE5B6C,KAAKsC,IAAI1B,MAAMI,MAAMxE,EAAKgO,IAAIG,QAChCoB,IAKN,OAAOA,EAAcD,qTCpMJE,aACnB,SAAAA,EAAY/O,EAAGE,EAAGhB,gGAAM4D,CAAAC,KAAAgM,GACtBhM,KAAKiM,GAAKhP,EACV+C,KAAKkM,GAAK/O,EACV6C,KAAKmM,MAAQhQ,mFAIb,OAAO6D,KAAKiM,6BAIZ,OAAOjM,KAAKkM,gCAIZ,OAAOlM,KAAKmM,iCAIZ,OAAQnM,KAAK/C,EAAG+C,KAAK7C,EAAG6C,KAAK7D,MAAM4N,KAAK,wTCpBvBqC,aACnB,SAAAA,EAAYzO,EAAQxB,EAAMyB,EAAUiD,EAAkBI,gGAAYlB,CAAAC,KAAAoM,GAChEpM,KAAKqM,QAAU1O,EACfqC,KAAKmM,MAAQhQ,EACb6D,KAAKsM,UAAY1O,EACjBoC,KAAKuM,kBAAoB1L,EACzBb,KAAKwM,YAAcvL,wFAInB,OAAOjB,KAAKqM,qCAIZ,OAAOrM,KAAKmM,uCAIZ,OAAOnM,KAAKsM,mDAIZ,OAAOtM,KAAKuM,qDAIZ,OAAOvM,KAAKwM,qJC1BhB,IAAA5M,EAAA7F,EAAA,6KAEqBwF,aACnB,SAAAA,EAAYyI,GAAsB,IAAdlI,EAAczD,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,mGAAA0D,CAAAC,KAAAT,GAChCS,KAAKyM,QAAUzE,EACfhI,KAAK0M,SAAW/R,OAAOyF,UAAPR,EAAA+M,qBAAwC7M,yFAWnDK,EAAS8H,GACd,IAAI2E,EAAiB,KAErB,OAAQ5M,KAAKF,QAAQd,MACnB,IAAK,SACH4N,EAAiB5M,KAAK6M,aACtB,MAEF,IAAK,SACHD,EAAiB5M,KAAK8M,aACtB,MAEF,IAAK,QACHF,EAAiB5M,KAAK+M,YAI1B,IAAKH,EACH,MAAM,IAAI1M,MAAJ,6BAAA7B,OAAuC2B,KAAKF,QAAQd,KAApD,MAENmB,EAAQsI,UAAYzI,KAAKF,QAAQf,MACjCoB,EAAQmL,YAActL,KAAKF,QAAQf,OAEnC6N,EAAiBA,EAAenR,KAAKuE,OACtBG,EAAS8H,wCAIf9H,EAAS8H,GACpB9H,EAAQ6M,OACR7M,EAAQyI,YACRzI,EAAQqL,IAAIvD,EAAS,GAAIA,EAAS,GAAI,EAAG,EAAG,EAAIxL,KAAKM,IACrDoD,EAAQ8I,OACR9I,EAAQ8M,8CAGE9M,EAAS8H,GACnB9H,EAAQ6M,OACR7M,EAAQyI,YACRzI,EAAQ+M,UAAY,EACpB/M,EAAQqL,IAAIvD,EAAS,GAAIA,EAAS,GAAI,EAAG,EAAG,EAAIxL,KAAKM,IACrDoD,EAAQ0L,SACR1L,EAAQ8M,+CAGG9M,EAAS8H,GACpB,IAGMhL,EAAIgL,EAAS,GAAKkF,UAClBhQ,EAAI8K,EAAS,GAHE,UAKrB9H,EAAQ6M,OACR7M,EAAQiN,UAAU,QAAU,EAAU,EAAU,QAAU,QAAWnQ,EAAG,QAAWE,GACnFgD,EAAQyI,YACRzI,EAAQ+M,UAAY,SACpB/M,EAAQ0I,OAAO,IAAY,WAC3B1I,EAAQkN,cAAc,WAAY,WAAY,UAAW,SAAW,SAAU,WAC9ElN,EAAQkN,eAAe,SAAU,UAAW,GAAW,UAAY,GAAW,WAC9ElN,EAAQkN,cAAc,GAAW,UAAY,UAAW,UAAW,UAAW,WAC9ElN,EAAQkN,cAAc,WAAY,QAAU,WAAY,UAAW,IAAY,WAC/ElN,EAAQ0I,OAAO,GAAW,WAC1B1I,EAAQkN,cAAc,UAAW,UAAW,UAAW,UAAW,UAAW,WAC7ElN,EAAQkN,cAAc,UAAW,UAAW,UAAW,SAAU,GAAW,UAC5ElN,EAAQkN,cAAc,UAAW,SAAU,UAAW,UAAW,UAAW,WAC5ElN,EAAQkN,cAAc,UAAW,UAAW,UAAW,UAAW,GAAW,WAC7ElN,EAAQ8I,OACR9I,EAAQ8M,yCA1ER,OAAOjN,KAAKyM,wCAIZ,OAAOzM,KAAK0M,kJCbhB,IAAA9M,EAAA7F,EAAA,GACA0F,mDAAAP,CAAAnF,EAAA,IACAuT,EAAAvT,EAAA,GACAwT,EAAAxT,EAAA,0KAEA,IAAMyT,KAEehO,aACnB,SAAAA,EAAYiO,GAAyB,IAAA5K,EAAA7C,KAAdF,EAAczD,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,mGAAA0D,CAAAC,KAAAR,GACnCQ,KAAK0N,WAAaD,EAClBzN,KAAK0M,SAAW/R,OAAOyF,UAAPR,EAAA+N,sBAAyC7N,GACzDE,KAAK4N,UAAY,KAEjBC,MAAM7N,KAAK0N,YACRI,KAAK,SAAAC,GAAQ,OAAIA,EAASC,SAC1BF,KAAK,SAAAE,GACJnL,EAAK+K,UAAYI,IAElBC,MAAM,SAAA5C,GAAG,OAAI6C,QAAQrR,IAAR,kBAAAwB,OAA8BwE,EAAK6K,WAAnC,MAAArP,OAAkDgN,EAAI8C,SAAW9C,4FAW5ElL,EAASiI,GACd,GAAKpI,KAAK4N,UAAV,CAIAzN,EAAQsI,UAAYzI,KAAKF,QAAQf,MACjCoB,EAAQmL,YAActL,KAAKF,QAAQf,MAEnCiB,KAAKoI,SAAWA,EAEhB,IAAMzK,GACJqC,KAAKoI,SAASvH,iBAAiB,GAAK,EACpCb,KAAKoI,SAASvH,iBAAiB,GAAK,GAGhCuM,GAAY,EAAAE,EAAAc,eAAcC,MAAOrO,KAAKsO,aAAclG,WAAUzK,WAE9D4Q,GAAO,EAAAjB,EAAAkB,SAAQpB,GAAWjN,QAAQA,GAExCA,EAAQyI,YACR2F,GAAK,EAAAhB,EAAAkB,MAAKzO,KAAK4N,YACfzN,EAAQ0L,+CAGG5O,EAAGE,GAAG,IAAAwI,EAAA3F,KAwBXiI,EAvBiB,SAAChL,EAAGE,EAAGiL,GAC5B,IAAMsG,EAAW7H,KAAKC,YACnB3J,EAAGF,GAAI0I,EAAKyC,SAASzK,OAAQgI,EAAKyC,SAASjM,KAC5CwJ,EAAKyC,SAASxK,SAAU+H,EAAKyC,SAASvH,mBAGxC,GAAI6N,KAAYlB,EACd,OAAOA,EAAckB,GAGvB,IAAMzG,EAAWxI,EAAAH,QAAe2F,eAC7B9H,EAAGF,GACJ0I,EAAKyC,SAASzK,OACdgI,EAAKyC,SAASjM,KACdwJ,EAAKyC,SAASxK,SACd+H,EAAKyC,SAASvH,kBAKhB,OAFA2M,EAAckB,GAAYzG,EAEnBA,EAGQ0G,CAAe1R,EAAGE,EAAG6C,KAAKoI,UAErCwG,EAAa5O,KAAKrC,OAAO,GAAKsK,EAAS,GAAKjI,KAAKoI,SAASnH,WAAW,GACrE4N,EAAa7O,KAAKrC,OAAO,GAAKsK,EAAS,GAAKjI,KAAKoI,SAASnH,WAAW,GAE3EjB,KAAK8O,OAAOT,MAAMO,EAAYC,qCA5D9B,OAAO7O,KAAK0N,2CAIZ,OAAO1N,KAAK0M,uFCnBD,IAAAqC,EAAA,WACf,WAAAC,GAGA,SAAAA,IACAhP,KAAAiP,QAGAD,EAAAnT,WACAqT,YAAAF,EACAC,MAAA,WACAjP,KAAAhE,EACAgE,KAAA7E,EAAA,GAEAgU,IAAA,SAAAhS,GACAgS,EAAAC,EAAAjS,EAAA6C,KAAA7E,GACAgU,EAAAnP,KAAAoP,EAAApT,EAAAgE,KAAAhE,GACAgE,KAAAhE,EAAAgE,KAAA7E,GAAAiU,EAAAjU,EACA6E,KAAAhE,EAAAoT,EAAAjU,GAEAkU,QAAA,WACA,OAAArP,KAAAhE,IAIA,IAAAoT,EAAA,IAAAJ,EAEA,SAAAG,EAAAJ,EAAA1I,EAAAC,GACA,IAAArJ,EAAA8R,EAAA/S,EAAAqK,EAAAC,EACAgJ,EAAArS,EAAAoJ,EACAkJ,EAAAtS,EAAAqS,EACAP,EAAA5T,EAAAkL,EAAAkJ,GAAAjJ,EAAAgJ,GCtCO,IAAAE,EAAA,KAEAC,EAAAhT,KAAAM,GACA2S,EAAAD,EAAA,EACAE,EAAAF,EAAA,EACAG,EAAA,EAAAH,EAEAI,EAAA,IAAAJ,EACAK,EAAAL,EAAA,IAEArK,EAAA3I,KAAA2I,IACAhI,EAAAX,KAAAW,KACA2S,EAAAtT,KAAAsT,MACA/S,EAAAP,KAAAO,IACA6M,EAAApN,KAAAoN,KACAxM,EAAAZ,KAAAY,IAEAR,GADAJ,KAAAE,MACAF,KAAAI,KACAH,EAAAD,KAAAC,IACAsT,EAAAvT,KAAAuT,IACIC,EAAIxT,KAAAyT,MAAA,SAAAjT,GAA6B,OAAAA,EAAA,IAAAA,EAAA,QACrCuH,EAAA/H,KAAA+H,KACA1H,EAAAL,KAAAK,IAEA,SAAAqT,EAAAlT,GACP,OAAAA,EAAA,IAAAA,GAAA,EAAAwS,EAAAhT,KAAA0T,KAAAlT,GAGO,SAAAmT,EAAAnT,GACP,OAAAA,EAAA,EAAAyS,EAAAzS,GAAA,GAAAyS,EAAAjT,KAAA2T,KAAAnT,GAGO,SAAAoT,EAAApT,GACP,OAAAA,EAAA+S,EAAA/S,EAAA,IAAAA,ECjCe,SAAAqT,KCAf,SAAAC,EAAAC,EAAA1B,GACA0B,GAAAC,EAAA3U,eAAA0U,EAAAxR,OACAyR,EAAAD,EAAAxR,MAAAwR,EAAA1B,GAIA,IAAA4B,GACAC,QAAA,SAAAhV,EAAAmT,GACAyB,EAAA5U,EAAA6U,SAAA1B,IAEA8B,kBAAA,SAAAjV,EAAAmT,GAEA,IADA,IAAA+B,EAAAlV,EAAAkV,SAAA5W,GAAA,EAAAyB,EAAAmV,EAAAvU,SACArC,EAAAyB,GAAA6U,EAAAM,EAAA5W,GAAAuW,SAAA1B,KAIA2B,GACAK,OAAA,SAAAnV,EAAAmT,GACAA,EAAAiC,UAEAC,MAAA,SAAArV,EAAAmT,GACAnT,IAAAsV,YACAnC,EAAAT,MAAA1S,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAuV,WAAA,SAAAvV,EAAAmT,GAEA,IADA,IAAAmC,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAAC,EAAAsV,EAAAhX,GAAA6U,EAAAT,MAAA1S,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAwV,WAAA,SAAAxV,EAAAmT,GACAsC,EAAAzV,EAAAsV,YAAAnC,EAAA,IAEAuC,gBAAA,SAAA1V,EAAAmT,GAEA,IADA,IAAAmC,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAA0V,EAAAH,EAAAhX,GAAA6U,EAAA,IAEAtP,QAAA,SAAA7D,EAAAmT,GACAwC,EAAA3V,EAAAsV,YAAAnC,IAEAyC,aAAA,SAAA5V,EAAAmT,GAEA,IADA,IAAAmC,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAA4V,EAAAL,EAAAhX,GAAA6U,IAEA0C,mBAAA,SAAA7V,EAAAmT,GAEA,IADA,IAAA2C,EAAA9V,EAAA8V,WAAAxX,GAAA,EAAAyB,EAAA+V,EAAAnV,SACArC,EAAAyB,GAAA6U,EAAAkB,EAAAxX,GAAA6U,KAIA,SAAAsC,EAAAH,EAAAnC,EAAA4C,GACA,IAAAC,EAAA1X,GAAA,EAAAyB,EAAAuV,EAAA3U,OAAAoV,EAEA,IADA5C,EAAA8C,cACA3X,EAAAyB,GAAAiW,EAAAV,EAAAhX,GAAA6U,EAAAT,MAAAsD,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA7C,EAAA+C,UAGA,SAAAP,EAAAL,EAAAnC,GACA,IAAA7U,GAAA,EAAAyB,EAAAuV,EAAA3U,OAEA,IADAwS,EAAAgD,iBACA7X,EAAAyB,GAAA0V,EAAAH,EAAAhX,GAAA6U,EAAA,GACAA,EAAAiD,aAGe,ICtDXC,EACJC,EACIC,EACAC,EACAC,EDkDWC,EAAA,SAAA1W,EAAAmT,GACfnT,GAAA+U,EAAA5U,eAAAH,EAAAqD,MACA0R,EAAA/U,EAAAqD,MAAArD,EAAAmT,GAEAyB,EAAA5U,EAAAmT,IC7DOwD,EAAkBvD,IAEzBwD,EAAcxD,IAOPyD,GACPnE,MAASiC,EACTsB,UAAatB,EACbuB,QAAWvB,EACXwB,aAAA,WACAQ,EAAArD,QACAuD,EAAAZ,UAAAa,EACAD,EAAAX,QAAAa,GAEAX,WAAA,WACA,IAAAY,GAAAL,EACAC,EAAApD,IAAAwD,EAAA,EAA+B/C,EAAG+C,KAClC3S,KAAA4R,UAAA5R,KAAA6R,QAAA7R,KAAAqO,MAAiDiC,GAEjDS,OAAA,WACAwB,EAAApD,IAAgBS,KAIhB,SAAA6C,IACAD,EAAAnE,MAAAuE,EAGA,SAAAF,IACAG,EAAYb,EAAQC,GAGpB,SAAAW,EAAAE,EAAAC,GACAP,EAAAnE,MAAAwE,EACEb,EAAQc,EAAAb,EAAAc,EAERb,EADFY,GAAYhD,EACQqC,EAAUnV,EAAG+V,GADdA,GAASjD,GACK,EAAiBH,GAAYyC,EAAUpC,EAAG+C,GAG3E,SAAAF,EAAAC,EAAAC,GAEAA,GADmBA,GAASjD,GAC5B,EAAkBH,EAKlB,IAAAqD,GANAF,GAAYhD,GAMaoC,EACzBe,EAAAD,GAAA,OACAE,EAAAD,EAAAD,EACAG,EAAenW,EAAG+V,GAClBK,EAAepD,EAAG+C,GAClBM,EAAUjB,EAAOgB,EACjBE,EAAUnB,EAAOgB,EAAAE,EAAgBrW,EAAGkW,GACpCK,EAAAF,EAAAJ,EAAyBjD,EAAGkD,GAC5BZ,EAAAnD,IAAkBY,EAAKwD,EAAAD,IAGrBpB,EAAOY,EAAWX,EAAOgB,EAAWf,EAAOgB,EAG9B,IAAAI,EAAA,SAAA7X,GAGf,OAFA4W,EAAAtD,QACEoD,EAAM1W,EAAA6W,GACR,EAAAD,GCtEO,SAASkB,EAASC,GACzB,OAAU3D,EAAK2D,EAAA,GAAAA,EAAA,IAA8BtD,EAAIsD,EAAA,KAG1C,SAASC,EAASC,GACzB,IAAAd,EAAAc,EAAA,GAAAb,EAAAa,EAAA,GAAAT,EAA0DnW,EAAG+V,GAC7D,OAAAI,EAAmBnW,EAAG8V,GAAAK,EAAmBnD,EAAG8C,GAAU9C,EAAG+C,IAGlD,SAAAc,EAAAxN,EAAAC,GACP,OAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAGO,SAAAwN,EAAAzN,EAAAC,GACP,OAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,IAIO,SAAAyN,EAAA1N,EAAAC,GACPD,EAAA,IAAAC,EAAA,GAAAD,EAAA,IAAAC,EAAA,GAAAD,EAAA,IAAAC,EAAA,GAGO,SAAA0N,GAAAC,EAAAZ,GACP,OAAAY,EAAA,GAAAZ,EAAAY,EAAA,GAAAZ,EAAAY,EAAA,GAAAZ,GAIO,SAAAa,GAAA3Z,GACP,IAAAL,EAAUsK,EAAIjK,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACdA,EAAA,IAAAL,EAAAK,EAAA,IAAAL,EAAAK,EAAA,IAAAL,ECzBA,IAAIia,GAASC,GAAMC,GAASC,GACxBC,GACAC,GAAUC,GACVC,GAEJC,GACAC,GAFAC,GAAe9F,IAIf+F,IACAzG,MAAA0G,GACAnD,UAAAoD,GACAnD,QAAAoD,GACAnD,aAAA,WACAgD,GAAAzG,MAAA6G,GACAJ,GAAAlD,UAAAuD,GACAL,GAAAjD,QAAAuD,GACAP,GAAA5F,QACIuD,EAAUV,gBAEdC,WAAA,WACIS,EAAUT,aACd+C,GAAAzG,MAAA0G,GACAD,GAAAlD,UAAAoD,GACAF,GAAAjD,QAAAoD,GACQ3C,EAAW,GAAM6B,KAAYE,GAAO,KAASD,KAASE,GAAI,KAClEO,GAAwBrF,EAAS8E,GAAI,GACrCO,IAAyBrF,IAAS4E,IAAI,IACtCQ,GAAA,GAAeT,GAAOS,GAAA,GAAaP,KAInC,SAAAU,GAAAjC,EAAAC,GACA4B,GAAA1S,KAAA2S,IAAuBT,GAAOrB,EAAWuB,GAAOvB,IAChDC,EAAYqB,KAAMA,GAAIrB,GACtBA,EAAYuB,KAAMA,GAAIvB,GAGtB,SAASsC,GAASvC,EAAAC,GAClB,IAAAhX,EAAU4X,GAASb,EAAWhD,EAAOiD,EAAQjD,IAC7C,GAAM4E,GAAE,CACR,IAAAY,EAAiBxB,EAAeY,GAAE3Y,GAElCwZ,EAAqBzB,GADrBwB,EAAA,IAAAA,EAAA,MACmCA,GAC/BpB,GAAyBqB,GAC7BA,EAAiB9B,EAAS8B,GAC1B,IAGAC,EAHAC,EAAA3C,EAAyByB,GACzBrE,EAAAuF,EAAA,OACAC,EAAAH,EAAA,GAAkC1F,EAAOK,EAEzCyF,EAAuBvQ,EAAGqQ,GAAA,IAC1BE,GAAAzF,EAA+BqE,GAAOmB,KAAAxF,EAAA4C,IACtC0C,EAAAD,EAAA,GAA6B1F,GACZyE,KAAMA,GAAIkB,GACtBG,GAAAzF,EAAwEqE,IAAxEmB,KAAA,eAA+EA,EAAAxF,EAAA4C,IACpF0C,GAAAD,EAAA,GAA8B1F,GACbuE,KAAMA,GAAIoB,IAE3BzC,EAAgBqB,KAAMA,GAAIrB,GAC1BA,EAAgBuB,KAAMA,GAAIvB,IAE1B4C,EACA7C,EAAmByB,GACPqB,GAAMzB,GAAOrB,GAAY8C,GAAMzB,GAASE,MAAUA,GAAOvB,GAEzD8C,GAAK9C,EAASuB,IAAWuB,GAAMzB,GAASE,MAAUF,GAAOrB,GAG3DuB,IAAWF,IACrBrB,EAAqBqB,KAASA,GAAOrB,GACrCA,EAAqBuB,KAASA,GAAOvB,IAErCA,EAAqByB,GACPqB,GAAMzB,GAAOrB,GAAY8C,GAAMzB,GAASE,MAAUA,GAAOvB,GAEzD8C,GAAK9C,EAASuB,IAAWuB,GAAMzB,GAASE,MAAUF,GAAOrB,QAKvE6B,GAAA1S,KAAA2S,IAAyBT,GAAOrB,EAAWuB,GAAOvB,IAElDC,EAAYqB,KAAMA,GAAIrB,GACtBA,EAAYuB,KAAMA,GAAIvB,GACpB2B,GAAE3Y,EAAMwY,GAAOzB,EAGjB,SAAAkC,KACAF,GAAAzG,MAAuBgH,GAGvB,SAAAJ,KACAL,GAAA,GAAaT,GAAOS,GAAA,GAAaP,GACjCS,GAAAzG,MAAA0G,GACEL,GAAE,KAGJ,SAAAQ,GAAApC,EAAAC,GACA,GAAM2B,GAAE,CACR,IAAAe,EAAA3C,EAAyByB,GACzBM,GAAA1F,IAAiB/J,EAAGqQ,GAAA,IAAAA,KAAA,YAAAA,QAEhBjB,GAAQ1B,EAAW2B,GAAK1B,EAE1BP,EAAUnE,MAAAyE,EAAAC,GACVsC,GAASvC,EAAAC,GAGX,SAAAoC,KACE3C,EAAUZ,YAGZ,SAAAwD,KACAF,GAAkBV,GAAUC,IAC1BjC,EAAUX,UACNzM,EAAGyP,IAAarF,IAAS2E,KAAYE,GAAO,MAClDO,GAAA,GAAaT,GAAOS,GAAA,GAAaP,GAC/BK,GAAE,KAMJ,SAASkB,GAAKC,EAAAC,GACd,OAAAA,GAAAD,GAAA,EAAAC,EAAA,IAAAA,EAGA,SAAAC,GAAA1P,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,GAGA,SAAA0P,GAAApB,EAAA3X,GACA,OAAA2X,EAAA,IAAAA,EAAA,GAAAA,EAAA,IAAA3X,MAAA2X,EAAA,GAAA3X,EAAA2X,EAAA,IAAAA,EAAA,GAAA3X,EAGe,ICxIfgZ,GAAAC,GACIC,GAAIC,GAAEC,GACNC,GAAIC,GAAEC,GACVC,GAAAC,GAAAC,GACIC,GAAUC,GACVC,GAAIC,GAAEC,GDmIKpP,GAAA,SAAAqP,GACf,IAAAhd,EAAAyB,EAAA2K,EAAAC,EAAA4Q,EAAAC,EAAA1B,EAOA,GALEnB,GAAOD,KAAYF,GAAUC,GAAIgD,KACnCzC,MACEtC,EAAM4E,EAAAnC,IAGRpZ,EAAAiZ,GAAArY,OAAA,CAIA,IAHAqY,GAAAvO,KAAA2P,IAGA9b,EAAA,EAAAid,GAAA7Q,EAAAsO,GAAA,IAA4C1a,EAAAyB,IAAOzB,EAEnD+b,GAAA3P,GADAC,EAAAqO,GAAA1a,IACA,KAAA+b,GAAA3P,EAAAC,EAAA,KACYsP,GAAKvP,EAAA,GAAAC,EAAA,IAAesP,GAAKvP,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAAC,EAAA,IACzBsP,GAAKtP,EAAA,GAAAD,EAAA,IAAeuP,GAAKvP,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAAC,EAAA,KAErC4Q,EAAAjV,KAAAoE,EAAAC,GAMA,IAAA6Q,GAAAC,IAAAnd,EAAA,EAAAoM,EAAA6Q,EAAAxb,EAAAwb,EAAA5a,OAAA,GAA2ErC,GAAAyB,EAAQ2K,EAAAC,IAAArM,EACnFqM,EAAA4Q,EAAAjd,IACAwb,EAAmBG,GAAKvP,EAAA,GAAAC,EAAA,KAAA6Q,MAAA1B,EAA4CtB,GAAO7N,EAAA,GAAS+N,GAAOhO,EAAA,IAM3F,OAFAsO,GAAAC,GAAA,KAEST,KAAOiD,KAAiBhD,KAAIgD,MACrCC,sBACUlD,GAASC,KAAQC,GAASC,MCnKpCgD,IACAvG,OAAUT,EACVjC,MAAAkJ,GACA3F,UAAA4F,GACA3F,QAAA4F,GACA3F,aAAA,WACAwF,GAAA1F,UAAA8F,GACAJ,GAAAzF,QAAA8F,IAEA5F,WAAA,WACAuF,GAAA1F,UAAA4F,GACAF,GAAAzF,QAAA4F,KAKA,SAAAF,GAAAzE,EAAAC,GACAD,GAAYhD,EACZ,IAAAqD,EAAenW,EADI+V,GAASjD,GAE5B8H,GAAAzE,EAAkCnW,EAAG8V,GAAAK,EAAmBnD,EAAG8C,GAAU9C,EAAG+C,IAGxE,SAAA6E,GAAA3a,EAAAE,EAAAD,GAEEiZ,KAAElZ,EAASkZ,MADbF,GAEEG,KAAEjZ,EAASiZ,IAAEH,GACfI,KAAAnZ,EAAAmZ,IAAAJ,GAGA,SAAAuB,KACAF,GAAAjJ,MAAAwJ,GAGA,SAAAA,GAAA/E,EAAAC,GACAD,GAAYhD,EACZ,IAAAqD,EAAenW,EADI+V,GAASjD,GAE1BgH,GAAE3D,EAAYnW,EAAG8V,GACjBiE,GAAE5D,EAAYnD,EAAG8C,GACnBkE,GAAOhH,EAAG+C,GACVuE,GAAAjJ,MAAAyJ,GACAF,GAAyBd,GAAIC,GAAEC,IAG/B,SAAAc,GAAAhF,EAAAC,GACAD,GAAYhD,EACZ,IAAAqD,EAAenW,EADI+V,GAASjD,GAE5B7S,EAAAkW,EAAmBnW,EAAG8V,GACtB3V,EAAAgW,EAAmBnD,EAAG8C,GACtB5V,EAAU8S,EAAG+C,GACbgF,EAAUhI,EAAMvL,GAAIuT,EAAMhB,GAAE7Z,EAAA8Z,GAAA7Z,GAAA4a,KAAAf,GAAA/Z,EAAmC6Z,GAAE5Z,GAAA6a,KAAiBjB,GAAE3Z,EAAO4Z,GAAE9Z,GAAA8a,GAAYjB,GAAE7Z,EAAO8Z,GAAE5Z,EAAA6Z,GAAA9Z,GACpHgZ,IAAA6B,EACEzB,IAAEyB,GAASjB,IAAMA,GAAE7Z,IACnBsZ,IAAEwB,GAAShB,IAAMA,GAAE5Z,IACrBqZ,IAAAuB,GAAAf,OAAA9Z,IACA0a,GAAyBd,GAAIC,GAAEC,IAG/B,SAAAS,KACAH,GAAAjJ,MAAAkJ,GAKA,SAAAG,KACAJ,GAAAjJ,MAAA2J,GAGA,SAAAL,KACAM,GAAoBrB,GAAUC,IAC9BS,GAAAjJ,MAAAkJ,GAGA,SAAAS,GAAAlF,EAAAC,GACE6D,GAAQ9D,EAAW+D,GAAK9D,EAC1BD,GAAYhD,EAAOiD,GAASjD,EAC5BwH,GAAAjJ,MAAA4J,GACA,IAAA9E,EAAenW,EAAG+V,GAChB+D,GAAE3D,EAAYnW,EAAG8V,GACjBiE,GAAE5D,EAAYnD,EAAG8C,GACnBkE,GAAOhH,EAAG+C,GACV6E,GAAyBd,GAAIC,GAAEC,IAG/B,SAAAiB,GAAAnF,EAAAC,GACAD,GAAYhD,EACZ,IAAAqD,EAAenW,EADI+V,GAASjD,GAE5B7S,EAAAkW,EAAmBnW,EAAG8V,GACtB3V,EAAAgW,EAAmBnD,EAAG8C,GACtB5V,EAAU8S,EAAG+C,GACbmF,EAAWnB,GAAE7Z,EAAA8Z,GAAA7Z,EACbgb,EAAAnB,GAAA/Z,EAAoB6Z,GAAE5Z,EACtBkb,EAAWtB,GAAE3Z,EAAO4Z,GAAE9Z,EACtB5C,EAAUmK,EAAI0T,IAAAC,IAAAC,KACdL,EAAU3H,EAAI/V,GACdkZ,EAAAlZ,IAAA0d,EAAA1d,EACAoc,IAAAlD,EAAA2E,EACAxB,IAAAnD,EAAA4E,EACAxB,IAAApD,EAAA6E,EACAlC,IAAA6B,EACEzB,IAAEyB,GAASjB,IAAMA,GAAE7Z,IACnBsZ,IAAEwB,GAAShB,IAAMA,GAAE5Z,IACrBqZ,IAAAuB,GAAAf,OAAA9Z,IACA0a,GAAyBd,GAAIC,GAAEC,IAG/B,IAAAqB,GAAA,SAAe1c,GACfsa,GAAAC,GACEC,GAAKC,GAAEC,GACPC,GAAKC,GAAEC,GACTC,GAAAC,GAAAC,GAAA,EACEtE,EAAM1W,EAAA2b,IAER,IAAAra,EAAAwZ,GACAtZ,EAAAuZ,GACAxZ,EAAAyZ,GACAtc,EAAA4C,IAAAE,IAAAD,IAGA,OAAA7C,ENhIO,QMiIP4C,EAAQqZ,GAAEnZ,EAAMoZ,GAAErZ,EAAAsZ,GAElBN,GAAa1G,IAAOvS,EAAMkZ,GAAEhZ,EAAMiZ,GAAElZ,EAAAmZ,KACpChc,EAAA4C,IAAAE,IAAAD,KNpIO,QMsIama,UAGVtH,EAAK5S,EAAAF,GAAS4S,EAASO,EAAIlT,EAAKsH,EAAInK,IAAOwV,IC1ItCyI,GAAA,SAAArb,GACf,kBACA,OAAAA,ICFesb,GAAA,SAAAlS,EAAAC,GAEf,SAAAiS,EAAAtb,EAAAE,GACA,OAAAF,EAAAoJ,EAAApJ,EAAAE,GAAAmJ,EAAArJ,EAAA,GAAAA,EAAA,IAOA,OAJAoJ,EAAAmS,QAAAlS,EAAAkS,SAAAD,EAAAC,OAAA,SAAAvb,EAAAE,GACA,OAAAF,EAAAqJ,EAAAkS,OAAAvb,EAAAE,KAAAkJ,EAAAmS,OAAAvb,EAAA,GAAAA,EAAA,MAGAsb,GCPA,SAAAE,GAAA3F,EAAAC,GACA,OAAU3N,EAAG0N,GAAWrD,EAAEqD,EAAArW,KAAA8H,OAAAuO,EAAiClD,GAAOA,EAAGkD,EAAAC,GAK9D,SAAA2F,GAAAC,EAAAC,EAAAC,GACP,OAAAF,GAAyB/I,GAAGgJ,GAAAC,EAA8BN,GAAOO,GAAAH,GAAAI,GAAAH,EAAAC,IACjEC,GAAAH,GACAC,GAAAC,EAAAE,GAAAH,EAAAC,GACAJ,GAGA,SAAAO,GAAAL,GACA,gBAAA7F,EAAAC,GACA,QAAAD,GAAA6F,GAA4ClJ,EAAEqD,EAAYlD,EAAGkD,GAAarD,EAAEqD,EAAYlD,EAAGkD,EAAAC,IAI3F,SAAA+F,GAAAH,GACA,IAAAM,EAAAD,GAAAL,GAEA,OADAM,EAAAT,OAAAQ,IAAAL,GACAM,EAGA,SAAAF,GAAAH,EAAAC,GACA,IAAAK,EAAoBlc,EAAG4b,GACvBO,EAAoBnJ,EAAG4I,GACvBQ,EAAsBpc,EAAG6b,GACzBQ,EAAsBrJ,EAAG6I,GAEzB,SAAAI,EAAAnG,EAAAC,GACA,IAAAI,EAAiBnW,EAAG+V,GACpB9V,EAAYD,EAAG8V,GAAAK,EACfhW,EAAY6S,EAAG8C,GAAAK,EACfjW,EAAY8S,EAAG+C,GACfM,EAAAnW,EAAAgc,EAAAjc,EAAAkc,EACA,OACMpJ,EAAK5S,EAAAic,EAAA/F,EAAAgG,EAAApc,EAAAic,EAAAhc,EAAAic,GACL/I,EAAIiD,EAAA+F,EAAAjc,EAAAkc,IAgBV,OAZAJ,EAAAT,OAAA,SAAA1F,EAAAC,GACA,IAAAI,EAAiBnW,EAAG+V,GACpB9V,EAAYD,EAAG8V,GAAAK,EACfhW,EAAY6S,EAAG8C,GAAAK,EACfjW,EAAY8S,EAAG+C,GACfM,EAAAnW,EAAAkc,EAAAjc,EAAAkc,EACA,OACMtJ,EAAK5S,EAAAic,EAAAlc,EAAAmc,EAAApc,EAAAic,EAAA7F,EAAA8F,GACL/I,EAAIiD,EAAA6F,EAAAjc,EAAAkc,KAIVF,EAnDAR,GAAAD,OAAAC,GAsDe,IAAAa,GAAA,SAAAC,GAGf,SAAAC,EAAAvI,GAEA,OADAA,EAAAsI,EAAAtI,EAAA,GAA0CnB,EAAOmB,EAAA,GAAmBnB,IACpE,IAA6BD,EAAOoB,EAAA,IAAoBpB,EAAOoB,EAQ/D,OAZAsI,EAAAb,GAAAa,EAAA,GAAqCzJ,EAAOyJ,EAAA,GAAczJ,EAAOyJ,EAAAjd,OAAA,EAAAid,EAAA,GAAkCzJ,EAAO,GAO1G0J,EAAAhB,OAAA,SAAAvH,GAEA,OADAA,EAAAsI,EAAAf,OAAAvH,EAAA,GAAiDnB,EAAOmB,EAAA,GAAmBnB,IAC3E,IAA6BD,EAAOoB,EAAA,IAAoBpB,EAAOoB,GAG/DuI,GCpEO,SAAAC,GAAA3K,EAAA4K,EAAAjE,EAAAkE,EAAAC,EAAAC,GACP,GAAApE,EAAA,CACA,IAAAqE,EAAkB9c,EAAG0c,GACrBK,EAAkB/J,EAAG0J,GACrBM,EAAAL,EAAAlE,EACA,MAAAmE,GACAA,EAAAF,EAAAC,EAA8B/J,EAC9BiK,EAAAH,EAAAM,EAAA,IAEAJ,EAAAK,GAAAH,EAAAF,GACAC,EAAAI,GAAAH,EAAAD,IACAF,EAAA,EAAAC,EAAAC,EAAAD,EAAAC,KAAAD,GAAAD,EAA6D/J,IAE7D,QAAAvB,EAAAlT,EAAAye,EAAyBD,EAAA,EAAAxe,EAAA0e,EAAA1e,EAAA0e,EAAiC1e,GAAA6e,EAC1D3L,EAAYoF,GAASqG,GAAAC,EAA0B/c,EAAG7B,IAAA4e,EAAkB/J,EAAG7U,KACvE2T,EAAAT,QAAA,GAAAA,EAAA,KAKA,SAAA4L,GAAAH,EAAAzL,IACAA,EAAUsF,EAAStF,IAAA,IAAAyL,EACjB5F,GAAyB7F,GAC3B,IAAAqL,EAAevJ,GAAI9B,EAAA,IACnB,SAAAA,EAAA,MAAAqL,KAA+C9J,EAAMJ,GAAWI,EAGjD,IAAAsK,GAAA,WACf,IAGAC,EACAZ,EAJA5b,EAAe2a,IAAQ,MACvBoB,EAAepB,GAAQ,IACvB8B,EAAkB9B,GAAQ,GAG1BxJ,GAAgBT,MAEhB,SAAApR,EAAAE,GACAgd,EAAAlY,KAAAhF,EAAAsc,EAAAtc,EAAAE,IACAF,EAAA,IAAY4S,EAAO5S,EAAA,IAAU4S,IAG7B,SAAAwK,IACA,IAAA/f,EAAAqD,EAAA2c,MAAAta,KAAA3D,WACAtB,EAAA2e,EAAAY,MAAAta,KAAA3D,WAA4CyT,EAC5C/T,EAAAqe,EAAAE,MAAAta,KAAA3D,WAA+CyT,EAM/C,OALAqK,KACAZ,EAAab,IAAape,EAAA,GAASwV,GAAOxV,EAAA,GAAUwV,EAAO,GAAA0I,OAC3DiB,GAAA3K,EAAA/T,EAAAgB,EAAA,GACAzB,GAAS0E,KAAA,UAAAiS,aAAAkJ,IACTA,EAAAZ,EAAA,KACAjf,EAeA,OAZA+f,EAAA1c,OAAA,SAAA4c,GACA,OAAAle,UAAAC,QAAAqB,EAAA,mBAAA4c,IAAsEjC,KAAQiC,EAAA,IAAAA,EAAA,KAAAF,GAAA1c,GAG9E0c,EAAAX,OAAA,SAAAa,GACA,OAAAle,UAAAC,QAAAod,EAAA,mBAAAa,IAAsEjC,IAAQiC,GAAAF,GAAAX,GAG9EW,EAAAD,UAAA,SAAAG,GACA,OAAAle,UAAAC,QAAA8d,EAAA,mBAAAG,IAAyEjC,IAAQiC,GAAAF,GAAAD,GAGjFC,GCpEeG,GAAA,WACf,IACAC,EADAC,KAEA,OACArM,MAAA,SAAApR,EAAAE,GACAsd,EAAAxY,MAAAhF,EAAAE,KAEAyU,UAAA,WACA8I,EAAAzY,KAAAwY,OAEA5I,QAAavB,EACbqK,OAAA,WACAD,EAAApe,OAAA,GAAAoe,EAAAzY,KAAAyY,EAAAE,MAAAvc,OAAAqc,EAAAjV,WAEAoV,OAAA,WACA,IAAAA,EAAAH,EAGA,OAFAA,KACAD,EAAA,KACAI,KClBeC,GAAA,SAAAzU,EAAAC,GACf,OAASlB,EAAGiB,EAAA,GAAAC,EAAA,IAAgBkJ,GAAWpK,EAAGiB,EAAA,GAAAC,EAAA,IAAgBkJ,GCD1D,SAAAuL,GAAA1M,EAAA2M,EAAAC,EAAAC,GACAlb,KAAA/C,EAAAoR,EACArO,KAAA9C,EAAA8d,EACAhb,KAAAtF,EAAAugB,EACAjb,KAAAmb,EAAAD,EACAlb,KAAAuT,GAAA,EACAvT,KAAAtE,EAAAsE,KAAAjE,EAAA,KAMe,IAAA4e,GAAA,SAAAS,EAAAC,EAAAC,EAAAC,EAAAzM,GACf,IAEA7U,EACAyB,EAHA8f,KACAC,KAwBA,GApBAL,EAAA3U,QAAA,SAAAiV,GACA,MAAAhgB,EAAAggB,EAAApf,OAAA,QACA,IAAAZ,EAAAuB,EAAA0e,EAAAD,EAAA,GAAAE,EAAAF,EAAAhgB,GAKA,GAAQof,GAAUa,EAAAC,GAAlB,CAEA,IADA9M,EAAA8C,YACA3X,EAAA,EAAiBA,EAAAyB,IAAOzB,EAAA6U,EAAAT,OAAAsN,EAAAD,EAAAzhB,IAAA,GAAA0hB,EAAA,IACxB7M,EAAA+C,eAIA2J,EAAAvZ,KAAAhF,EAAA,IAAA8d,GAAAY,EAAAD,EAAA,UACAD,EAAAxZ,KAAAhF,EAAAvC,EAAA,IAAAqgB,GAAAY,EAAA,KAAA1e,GAAA,IACAue,EAAAvZ,KAAAhF,EAAA,IAAA8d,GAAAa,EAAAF,EAAA,UACAD,EAAAxZ,KAAAhF,EAAAvC,EAAA,IAAAqgB,GAAAa,EAAA,KAAA3e,GAAA,OAGAue,EAAAlf,OAAA,CAMA,IAJAmf,EAAArV,KAAAiV,GACEQ,GAAIL,GACJK,GAAIJ,GAENxhB,EAAA,EAAAyB,EAAA+f,EAAAnf,OAA8BrC,EAAAyB,IAAOzB,EACrCwhB,EAAAxhB,GAAAkhB,EAAAG,KAOA,IAJA,IACAN,EACA3M,EAFAyN,EAAAN,EAAA,KAIA,CAIA,IAFA,IAAAO,EAAAD,EACAE,GAAA,EACAD,EAAAxI,GAAA,IAAAwI,IAAArgB,KAAAogB,EAAA,OACAd,EAAAe,EAAA7e,EACA4R,EAAA8C,YACA,GAEA,GADAmK,EAAAxI,EAAAwI,EAAArhB,EAAA6Y,GAAA,EACAwI,EAAAZ,EAAA,CACA,GAAAa,EACA,IAAA/hB,EAAA,EAAAyB,EAAAsf,EAAA1e,OAAwCrC,EAAAyB,IAAOzB,EAAA6U,EAAAT,SAAA2M,EAAA/gB,IAAA,GAAAoU,EAAA,SAE/CkN,EAAAQ,EAAA9e,EAAA8e,EAAArgB,EAAAuB,EAAA,EAAA6R,GAEAiN,IAAArgB,MACO,CACP,GAAAsgB,EAEA,IADAhB,EAAAe,EAAAhgB,EAAAmB,EACAjD,EAAA+gB,EAAA1e,OAAA,EAAqCrC,GAAA,IAAQA,EAAA6U,EAAAT,SAAA2M,EAAA/gB,IAAA,GAAAoU,EAAA,SAE7CkN,EAAAQ,EAAA9e,EAAA8e,EAAAhgB,EAAAkB,GAAA,EAAA6R,GAEAiN,IAAAhgB,EAGAif,GADAe,IAAArhB,GACAwC,EACA8e,YACKD,EAAAxI,GACLzE,EAAA+C,aAIA,SAASgK,GAAII,GACb,GAAAvgB,EAAAugB,EAAA3f,OAAA,CAKA,IAJA,IAAAZ,EAGA4K,EAFArM,EAAA,EACAoM,EAAA4V,EAAA,KAEAhiB,EAAAyB,GACA2K,EAAA3K,EAAA4K,EAAA2V,EAAAhiB,GACAqM,EAAAvK,EAAAsK,EACAA,EAAAC,EAEAD,EAAA3K,EAAA4K,EAAA2V,EAAA,GACA3V,EAAAvK,EAAAsK,GC/FA,IAAI6V,GAAMnN,IAEKoN,GAAA,SAAA9T,EAAAgG,GACf,IAAAyE,EAAAzE,EAAA,GACA0E,EAAA1E,EAAA,GACA+E,EAAepD,EAAG+C,GAClBuC,GAAgBtF,EAAG8C,IAAW9V,EAAG8V,GAAA,GACjCsJ,EAAA,EACAC,EAAA,EAEEH,GAAGjN,QAEL,IAAAmE,EAAAL,EAA0BrD,EAASF,GACnC,IAAA4D,IAAAL,GAAiCrD,EAASF,GAE1C,QAAAvV,EAAA,EAAAyB,EAAA2M,EAAA/L,OAAqCrC,EAAAyB,IAAOzB,EAC5C,GAAAI,GAAA8f,EAAA9R,EAAApO,IAAAqC,OASA,IARA,IAAA6d,EACA9f,EACAiiB,EAAAnC,EAAA9f,EAAA,GACAwb,EAAAyG,EAAA,GACAC,EAAAD,EAAA,KAA+B3M,EAC/B6M,EAAkBxM,EAAGuM,GACrBE,EAAkBzf,EAAGuf,GAErBG,EAAA,EAAmBA,EAAAriB,IAAOqiB,EAAA7G,EAAAC,EAAA0G,EAAAG,EAAAF,EAAAG,EAAAN,EAAAO,EAAA,CAC1B,IAAAA,EAAA1C,EAAAuC,GACA5G,EAAA+G,EAAA,GACAC,EAAAD,EAAA,KAAiClN,EACjCgN,EAAoB3M,EAAG8M,GACvBF,EAAoB5f,EAAG8f,GACvBrH,EAAAK,EAAAD,EACA3F,EAAAuF,GAAA,OACAsH,EAAA7M,EAAAuF,EACAE,EAAAoH,EAAoCtN,EACpC4D,EAAAmJ,EAAAG,EAOA,GALMT,GAAG/M,IAAKY,EAAKsD,EAAAnD,EAAYF,EAAG+M,GAAAN,EAAAG,EAAAvJ,EAAoCrW,EAAG+f,KACzEX,GAAAzG,EAAAF,EAAAvF,EAA6CN,EAAG6F,EAIhDE,EAAAE,GAAA/C,EAAAgD,GAAAhD,EAAA,CACA,IAAAtH,EAAkBsI,EAAeH,EAAS2I,GAAU3I,EAASkJ,IACrD3I,GAAyB1I,GACjC,IAAAwR,EAA2BlJ,EAAcwB,EAAA9J,GACjC0I,GAAyB8I,GACjC,IAAAC,GAAAtH,EAAAF,GAAA,QAA4DrF,EAAI4M,EAAA,KAChEjK,EAAAkK,GAAAlK,IAAAkK,IAAAzR,EAAA,IAAAA,EAAA,OACA6Q,GAAA1G,EAAAF,GAAA,SAiBA,OAAA2G,GAAmB5M,GAAO4M,EAAY5M,GAAW0M,IAAO1M,GAAO,EAAA6M,GCtEhDa,GAAA,SAAA7W,EAAAC,GACf,OAAAD,EAAAC,GAAA,EAAAD,EAAAC,EAAA,EAAAD,GAAAC,EAAA,EAAA+Q,KCEA,IAAA8F,GCDe,SAAAC,GAEf,OADA,IAAAA,EAAA9gB,SAAA8gB,EAyBA,SAAAC,GACA,gBAAA9iB,EAAA0C,GACA,OAAWigB,GAASG,EAAA9iB,GAAA0C,IA3BpBqgB,CAAAF,KAEAG,KAAA,SAAAlX,EAAApJ,EAAAugB,EAAAC,GAGA,IAFA,MAAAD,MAAA,GACA,MAAAC,MAAApX,EAAA/J,QACAkhB,EAAAC,GAAA,CACA,IAAAC,EAAAF,EAAAC,IAAA,EACAL,EAAA/W,EAAAqX,GAAAzgB,GAAA,EAAAugB,EAAAE,EAAA,EACAD,EAAAC,EAEA,OAAAF,GAEAG,MAAA,SAAAtX,EAAApJ,EAAAugB,EAAAC,GAGA,IAFA,MAAAD,MAAA,GACA,MAAAC,MAAApX,EAAA/J,QACAkhB,EAAAC,GAAA,CACA,IAAAC,EAAAF,EAAAC,IAAA,EACAL,EAAA/W,EAAAqX,GAAAzgB,GAAA,EAAAwgB,EAAAC,EACAF,EAAAE,EAAA,EAEA,OAAAF,IDpBsBI,CAASV,IACxBC,GAAAQ,MACAR,GAAAI,KEHQ,ICFXM,GAAKzb,MAAAvG,UCAMiiB,IDEID,GAAKE,MACPF,GAAKvb,ICHP,SAAAwZ,EAAAkC,EAAAhE,GACf8B,KAAAkC,KAAAhE,GAAAte,EAAAW,UAAAC,QAAA,GAAA0hB,EAAAlC,IAAA,KAAApgB,EAAA,KAAAse,EAMA,IAJA,IAAA/f,GAAA,EACAyB,EAAA,EAAAe,KAAAqI,IAAA,EAAArI,KAAAoN,MAAAmU,EAAAlC,GAAA9B,IACApF,EAAA,IAAAxS,MAAA1G,KAEAzB,EAAAyB,GACAkZ,EAAA3a,GAAA6hB,EAAA7hB,EAAA+f,EAGA,OAAApF,ICXAnY,KAAA+H,KAAA,IACA/H,KAAA+H,KAAA,IACA/H,KAAA+H,KAAA,GCFe,ICAAyZ,GAAA,SAAAC,GAQf,IAPA,IACA7jB,EAGA6c,EACA+E,EALAvgB,EAAAwiB,EAAA5hB,OAEArC,GAAA,EACAyiB,EAAA,IAIAziB,EAAAyB,GAAAghB,GAAAwB,EAAAjkB,GAAAqC,OAGA,IAFA4a,EAAA,IAAA9U,MAAAsa,KAEAhhB,GAAA,GAGA,IADArB,GADA4hB,EAAAiC,EAAAxiB,IACAY,SACAjC,GAAA,GACA6c,IAAAwF,GAAAT,EAAA5hB,GAIA,OAAA6c,GCjBe,ICIAiH,GAAA,SAAAC,EAAAC,EAAA9C,EAAAO,GACf,gBAAAwC,GACA,IAIAjW,EACA+S,EACAjB,EANAM,EAAA4D,EAAAC,GACAC,EAAqB/D,KACrBgE,EAAAH,EAAAE,GACAE,GAAA,EAKAhD,GACApN,QACAuD,YACAC,UACAC,aAAA,WACA2J,EAAApN,MAAAqQ,EACAjD,EAAA7J,UAAA+M,EACAlD,EAAA5J,QAAA+M,EACAxD,KACA/S,MAEA0J,WAAA,WACA0J,EAAApN,QACAoN,EAAA7J,YACA6J,EAAA5J,UACAuJ,EAAmB6C,GAAK7C,GACxB,IAAAE,EAA0Ba,GAAe9T,EAAAyT,GACzCV,EAAA9e,QACAmiB,IAAAH,EAAAxM,eAAA2M,GAAA,GACU9D,GAAUS,EAAWyD,GAAmBvD,EAAAC,EAAA+C,IACzChD,IACTmD,IAAAH,EAAAxM,eAAA2M,GAAA,GACAH,EAAA1M,YACA2J,EAAA,YAAA+C,GACAA,EAAAzM,WAEA4M,IAAAH,EAAAvM,aAAA0M,GAAA,GACArD,EAAA/S,EAAA,MAEA0I,OAAA,WACAuN,EAAAxM,eACAwM,EAAA1M,YACA2J,EAAA,YAAA+C,GACAA,EAAAzM,UACAyM,EAAAvM,eAIA,SAAA1D,EAAAyE,EAAAC,GACAqL,EAAAtL,EAAAC,IAAAuL,EAAAjQ,MAAAyE,EAAAC,GAGA,SAAA+L,EAAAhM,EAAAC,GACA0H,EAAApM,MAAAyE,EAAAC,GAGA,SAAAnB,IACA6J,EAAApN,MAAAyQ,EACArE,EAAA7I,YAGA,SAAAC,IACA4J,EAAApN,QACAoM,EAAA5I,UAGA,SAAA6M,EAAA5L,EAAAC,GACAoH,EAAAlY,MAAA6Q,EAAAC,IACAyL,EAAAnQ,MAAAyE,EAAAC,GAGA,SAAA4L,IACAH,EAAA5M,YACAuI,KAGA,SAAAyE,IACAF,EAAAvE,EAAA,MAAAA,EAAA,OACAqE,EAAA3M,UAEA,IAEA5X,EAAAI,EACAqhB,EACArN,EAJA0Q,EAAAP,EAAAO,QACAC,EAAAT,EAAA1D,SACAnf,EAAAsjB,EAAA1iB,OAQA,GAJA6d,EAAAS,MACAvS,EAAApG,KAAAkY,GACAA,EAAA,KAEAze,EAGA,KAAAqjB,GAEA,IAAA1kB,GADAqhB,EAAAsD,EAAA,IACA1iB,OAAA,MAGA,IAFAmiB,IAAAH,EAAAxM,eAAA2M,GAAA,GACAH,EAAA1M,YACA3X,EAAA,EAAqBA,EAAAI,IAAOJ,EAAAqkB,EAAAjQ,SAAAqN,EAAAzhB,IAAA,GAAAoU,EAAA,IAC5BiQ,EAAAzM,gBAOAnW,EAAA,KAAAqjB,GAAAC,EAAA/c,KAAA+c,EAAApE,MAAAvc,OAAA2gB,EAAAvZ,UAEA2V,EAAAnZ,KAAA+c,EAAArb,OAAAsb,KAGA,OAAAxD,IAIA,SAAAwD,GAAAvD,GACA,OAAAA,EAAApf,OAAA,EAKA,SAASuiB,GAAmBxY,EAAAC,GAC5B,QAAAD,IAAApJ,GAAA,KAAAoJ,EAAA,GAAoCqJ,EAASF,EAAUE,EAAMrJ,EAAA,MAC7DC,IAAArJ,GAAA,KAAAqJ,EAAA,GAAoCoJ,EAASF,EAAUE,EAAMpJ,EAAA,IC9H7D,IAAA4Y,GAAef,GACf,WAAc,UASd,SAAArP,GACA,IAGAiQ,EAHAlJ,EAAAwB,IACAkF,EAAAlF,IACA8H,EAAA9H,IAGA,OACAzF,UAAA,WACA9C,EAAA8C,YACAmN,EAAA,GAEA1Q,MAAA,SAAAyH,EAAAgH,GACA,IAAAsC,EAAAtJ,EAAA,EAAgCrG,GAAMA,EACtCgG,EAAkBrQ,EAAG0Q,EAAAD,GACXzQ,EAAGqQ,EAAShG,GAAMD,GAC5BV,EAAAT,MAAAwH,EAAA0G,KAAAO,GAAA,IAA6DpN,GAAUA,GACvEZ,EAAAT,MAAA8Q,EAAA5C,GACAzN,EAAA+C,UACA/C,EAAA8C,YACA9C,EAAAT,MAAA+Q,EAAA7C,GACAzN,EAAAT,MAAAyH,EAAAyG,GACAwC,EAAA,GACOI,IAAAC,GAAA3J,GAAsChG,IACjCrK,EAAGyQ,EAAAsJ,GAAoB3P,IAAOqG,GAAAsJ,EAAqB3P,GACnDpK,EAAG0Q,EAAAsJ,GAAoB5P,IAAOsG,GAAAsJ,EAAqB5P,GAC/D+M,EAoBA,SAAA1G,EAAA0G,EAAAzG,EAAAgH,GACA,IAAAL,EACAG,EACAyC,EAA0BrP,EAAG6F,EAAAC,GAC7B,OAAS1Q,EAAGia,GAAsB7P,EAC1BpS,GAAM4S,EAAGuM,IAAAK,EAAoB5f,EAAG8f,IAAU9M,EAAG8F,GACzC9F,EAAG8M,IAAAL,EAAoBzf,EAAGuf,IAAUvM,EAAG6F,KACnD4G,EAAAG,EAAAyC,KACA9C,EAAAO,GAAA,EA5BAwC,CAAAzJ,EAAA0G,EAAAzG,EAAAgH,GACAhO,EAAAT,MAAA8Q,EAAA5C,GACAzN,EAAA+C,UACA/C,EAAA8C,YACA9C,EAAAT,MAAA+Q,EAAA7C,GACAwC,EAAA,GAEAjQ,EAAAT,MAAAwH,EAAAC,EAAAyG,EAAAO,GACAqC,EAAAC,GAEAvN,QAAA,WACA/C,EAAA+C,UACAgE,EAAA0G,EAAAlF,KAEA0H,MAAA,WACA,SAAAA,KAgBA,SAAAQ,EAAAC,EAAA7F,EAAA7K,GACA,IAAAiE,EACA,SAAAwM,EACAxM,EAAA4G,EAAsBjK,EACtBZ,EAAAT,OAAkBoB,EAAEsD,GACpBjE,EAAAT,MAAA,EAAA0E,GACAjE,EAAAT,MAAiBoB,EAAEsD,GACnBjE,EAAAT,MAAiBoB,EAAE,GACnBX,EAAAT,MAAiBoB,GAAEsD,GACnBjE,EAAAT,MAAA,GAAA0E,GACAjE,EAAAT,OAAkBoB,GAAEsD,GACpBjE,EAAAT,OAAkBoB,EAAE,GACpBX,EAAAT,OAAkBoB,EAAEsD,QACjB,GAAU3N,EAAGma,EAAA,GAAAC,EAAA,IAAoBhQ,EAAO,CAC3C,IAAAsD,EAAAyM,EAAA,GAAAC,EAAA,GAAmC/P,GAAMA,EACzCsD,EAAA4G,EAAA7G,EAAA,EACAhE,EAAAT,OAAAyE,EAAAC,GACAjE,EAAAT,MAAA,EAAA0E,GACAjE,EAAAT,MAAAyE,EAAAC,QAEAjE,EAAAT,MAAAmR,EAAA,GAAAA,EAAA,OAlFI/P,GAAKC,ICDM,IAAA+P,GAAA,SAAA/F,GACf,IAAAgG,EAAW1iB,EAAG0c,GACdjE,EAAA,EAAkB3F,EAClB6P,EAAAD,EAAA,EACAE,EAAsBxa,EAAGsa,GAAOlQ,EAMhC,SAAAqQ,EAAA/M,EAAAC,GACA,OAAW/V,EAAG8V,GAAW9V,EAAG+V,GAAA2M,EAuF5B,SAAAI,EAAAzZ,EAAAC,EAAAyZ,GACA,IAKAC,GAAA,OACAC,EAAanM,EANAH,EAAStN,GACTsN,EAASrN,IAMtB4Z,EAAerM,EAAYoM,KAC3BE,EAAAF,EAAA,GACAG,EAAAF,EAAAC,IAGA,IAAAC,EAAA,OAAAL,GAAA1Z,EAEA,IAAAga,EAAAX,EAAAQ,EAAAE,EACAE,GAAAZ,EAAAS,EAAAC,EACAG,EAAgBzM,EAAckM,EAAAC,GAC9BO,EAAYxM,GAAcgM,EAAAK,GAEtBtM,EAAmByM,EADXxM,GAAciM,EAAAK,IAI1B,IAAAhN,EAAAiN,EACAxI,EAAYlE,EAAY2M,EAAAlN,GACxBmN,EAAa5M,EAAYP,KACzBoN,EAAA3I,IAAA0I,GAA2B5M,EAAY2M,KAAA,GAEvC,KAAAE,EAAA,IAEA,IAAAvlB,EAAYqJ,EAAIkc,GAChBC,EAAY3M,GAAcV,IAAAyE,EAAA5c,GAAAslB,GAI1B,GAHI1M,EAAmB4M,EAAAH,GACvBG,EAAQlN,EAASkN,IAEjBZ,EAAA,OAAAY,EAGA,IAIAzjB,EAJA2Y,EAAAxP,EAAA,GACAyP,EAAAxP,EAAA,GACAiW,EAAAlW,EAAA,GACAyW,EAAAxW,EAAA,GAGAwP,EAAAD,IAAA3Y,EAAA2Y,IAAAC,IAAA5Y,GAEA,IAAAuY,EAAAK,EAAAD,EACA+K,EAAgBxb,EAAGqQ,EAAShG,GAAMD,EAMlC,IAHAoR,GAAA9D,EAAAP,IAAArf,EAAAqf,IAAAO,IAAA5f,GAFA0jB,GAAAnL,EAAoCjG,EAMpCoR,EACArE,EAAAO,EAAA,EAAA6D,EAAA,IAAsCvb,EAAGub,EAAA,GAAA9K,GAAmBrG,EAAO+M,EAAAO,GACnEP,GAAAoE,EAAA,IAAAA,EAAA,IAAA7D,EACArH,EAAkBhG,GAAEoG,GAAA8K,EAAA,IAAAA,EAAA,IAAA7K,GAAA,CACpB,IAAA+K,EAAe7M,GAAcV,IAAAyE,EAAA5c,GAAAslB,GAE7B,OADM1M,EAAmB8M,EAAAL,IACzBG,EAAiBlN,EAASoN,MAM1B,SAAAC,EAAAhO,EAAAC,GACA,IAAAhY,EAAA4kB,EAAAjG,EAAmCjK,EAAEiK,EACrCoH,EAAA,EAKA,OAJAhO,GAAA/X,EAAA+lB,GAAA,EACAhO,EAAA/X,IAAA+lB,GAAA,GACA/N,GAAAhY,EAAA+lB,GAAA,EACA/N,EAAAhY,IAAA+lB,GAAA,GACAA,EAGA,OAAS3C,GAAI0B,EA5Jb,SAAA/Q,GACA,IAAAwN,EACAyE,EACAC,EACAC,EACAlC,EACA,OACAnN,UAAA,WACAqP,EAAAD,GAAA,EACAjC,EAAA,GAEA1Q,MAAA,SAAAyE,EAAAC,GACA,IACAmO,EADArE,GAAA/J,EAAAC,GAEAQ,EAAAsM,EAAA/M,EAAAC,GACAzY,EAAAqlB,EACApM,EAAA,EAAAuN,EAAAhO,EAAAC,GACAQ,EAAAuN,EAAAhO,KAAA,EAAgDrD,GAAMA,GAAEsD,GAAA,EAYxD,IAXAuJ,IAAA2E,EAAAD,EAAAzN,IAAAzE,EAAA8C,YAGA2B,IAAAyN,MACAE,EAAApB,EAAAxD,EAAAO,KACyB/B,GAAUwB,EAAA4E,IAAoBpG,GAAU+B,EAAAqE,MACjErE,EAAA,IAAyBrN,EACzBqN,EAAA,IAAyBrN,EACzB+D,EAAAsM,EAAAhD,EAAA,GAAAA,EAAA,KAGAtJ,IAAAyN,EACAjC,EAAA,EACAxL,GAEAzE,EAAA8C,YACAsP,EAAApB,EAAAjD,EAAAP,GACAxN,EAAAT,MAAA6S,EAAA,GAAAA,EAAA,MAGAA,EAAApB,EAAAxD,EAAAO,GACA/N,EAAAT,MAAA6S,EAAA,GAAAA,EAAA,IACApS,EAAA+C,WAEAyK,EAAA4E,OACS,GAAAtB,GAAAtD,GAAAqD,EAAApM,EAAA,CACT,IAAApY,EAGAb,EAAAymB,KAAA5lB,EAAA2kB,EAAAjD,EAAAP,GAAA,MACAyC,EAAA,EACAY,GACA7Q,EAAA8C,YACA9C,EAAAT,MAAAlT,EAAA,MAAAA,EAAA,OACA2T,EAAAT,MAAAlT,EAAA,MAAAA,EAAA,OACA2T,EAAA+C,YAEA/C,EAAAT,MAAAlT,EAAA,MAAAA,EAAA,OACA2T,EAAA+C,UACA/C,EAAA8C,YACA9C,EAAAT,MAAAlT,EAAA,MAAAA,EAAA,UAIAoY,GAAA+I,GAA8BxB,GAAUwB,EAAAO,IACxC/N,EAAAT,MAAAwO,EAAA,GAAAA,EAAA,IAEAP,EAAAO,EAAAmE,EAAAzN,EAAAwN,EAAAzmB,GAEAuX,QAAA,WACAmP,GAAAlS,EAAA+C,UACAyK,EAAA,MAIAyC,MAAA,WACA,OAAAA,GAAAkC,GAAAD,IAAA,KAtFA,SAAAzB,EAAAC,EAAA7F,EAAA7K,GACI2K,GAAY3K,EAAA4K,EAAAjE,EAAAkE,EAAA4F,EAAAC,IAuKHG,GAAA,GAAAjG,KAAgEjK,EAAEiK,EAAWjK,KCpL3E0R,GAAA,SAAA9a,EAAAC,EAAA8a,EAAAC,EAAAC,EAAAC,GACf,IAQAxmB,EARAymB,EAAAnb,EAAA,GACAob,EAAApb,EAAA,GAGAuT,EAAA,EACAC,EAAA,EACA6H,EAJApb,EAAA,GAIAkb,EACAG,EAJArb,EAAA,GAIAmb,EAIA,GADA1mB,EAAAqmB,EAAAI,EACAE,KAAA3mB,EAAA,IAEA,GADAA,GAAA2mB,EACAA,EAAA,GACA,GAAA3mB,EAAA6e,EAAA,OACA7e,EAAA8e,MAAA9e,QACG,GAAA2mB,EAAA,GACH,GAAA3mB,EAAA8e,EAAA,OACA9e,EAAA6e,MAAA7e,GAIA,GADAA,EAAAumB,EAAAE,EACAE,KAAA3mB,EAAA,IAEA,GADAA,GAAA2mB,EACAA,EAAA,GACA,GAAA3mB,EAAA8e,EAAA,OACA9e,EAAA6e,MAAA7e,QACG,GAAA2mB,EAAA,GACH,GAAA3mB,EAAA6e,EAAA,OACA7e,EAAA8e,MAAA9e,GAIA,GADAA,EAAAsmB,EAAAI,EACAE,KAAA5mB,EAAA,IAEA,GADAA,GAAA4mB,EACAA,EAAA,GACA,GAAA5mB,EAAA6e,EAAA,OACA7e,EAAA8e,MAAA9e,QACG,GAAA4mB,EAAA,GACH,GAAA5mB,EAAA8e,EAAA,OACA9e,EAAA6e,MAAA7e,GAIA,GADAA,EAAAwmB,EAAAE,EACAE,KAAA5mB,EAAA,IAEA,GADAA,GAAA4mB,EACAA,EAAA,GACA,GAAA5mB,EAAA8e,EAAA,OACA9e,EAAA6e,MAAA7e,QACG,GAAA4mB,EAAA,GACH,GAAA5mB,EAAA6e,EAAA,OACA7e,EAAA8e,MAAA9e,GAKA,OAFA6e,EAAA,IAAAvT,EAAA,GAAAmb,EAAA5H,EAAA8H,EAAArb,EAAA,GAAAob,EAAA7H,EAAA+H,GACA9H,EAAA,IAAAvT,EAAA,GAAAkb,EAAA3H,EAAA6H,EAAApb,EAAA,GAAAmb,EAAA5H,EAAA8H,IACA,OCnDAC,GAAA,IAAAC,IAAAD,GAKe,SAAAE,GAAAV,EAAAC,EAAAC,EAAAC,GAEf,SAAA1B,EAAA5iB,EAAAE,GACA,OAAAikB,GAAAnkB,MAAAqkB,GAAAD,GAAAlkB,MAAAokB,EAGA,SAAAhG,EAAAgE,EAAAC,EAAA7F,EAAA7K,GACA,IAAAzI,EAAA,EAAA0b,EAAA,EACA,SAAAxC,IACAlZ,EAAA2b,EAAAzC,EAAA5F,OAAAoI,EAAAC,EAAAxC,EAAA7F,KACAsI,EAAA1C,EAAAC,GAAA,EAAA7F,EAAA,EACA,GAAA7K,EAAAT,MAAA,IAAAhI,GAAA,IAAAA,EAAA+a,EAAAE,EAAAjb,EAAA,EAAAkb,EAAAF,UACAhb,KAAAsT,EAAA,QAAAoI,QAEAjT,EAAAT,MAAAmR,EAAA,GAAAA,EAAA,IAIA,SAAAwC,EAAAjmB,EAAA4d,GACA,OAAWvU,EAAGrJ,EAAA,GAAAqlB,GAAc5R,EAAOmK,EAAA,MACzBvU,EAAGrJ,EAAA,GAAAulB,GAAc9R,EAAOmK,EAAA,MACxBvU,EAAGrJ,EAAA,GAAAslB,GAAc7R,EAAOmK,EAAA,MAClCA,EAAA,MAGA,SAAA0B,EAAAhV,EAAAC,GACA,OAAA2b,EAAA5b,EAAApJ,EAAAqJ,EAAArJ,GAGA,SAAAglB,EAAA5b,EAAAC,GACA,IAAA4b,EAAAF,EAAA3b,EAAA,GACA8b,EAAAH,EAAA1b,EAAA,GACA,OAAA4b,IAAAC,EAAAD,EAAAC,EACA,IAAAD,EAAA5b,EAAA,GAAAD,EAAA,GACA,IAAA6b,EAAA7b,EAAA,GAAAC,EAAA,GACA,IAAA4b,EAAA7b,EAAA,GAAAC,EAAA,GACAA,EAAA,GAAAD,EAAA,GAGA,gBAAAyI,GACA,IAEAsM,EACA/S,EACA8R,EACAiI,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,EACAC,EACA3D,EARA4D,EAAA7T,EACA8T,EAAuBpI,KASvBqI,GACAxU,QACAuD,UAgDA,WACAiR,EAAAxU,MAAAyU,EACAza,KAAApG,KAAAkY,MACAuI,GAAA,EACAD,GAAA,EACAF,EAAAC,EAAAnL,KApDAxF,QA0DA,WACAuJ,IACA0H,EAAAV,EAAAC,GACAC,GAAAG,GAAAG,EAAAjI,SACAS,EAAAnZ,KAAA2gB,EAAA/H,WAEAgI,EAAAxU,QACAoU,GAAAE,EAAA9Q,WAhEAC,aAuBA,WACA6Q,EAAAC,EAAAxH,KAAA/S,KAAA0W,GAAA,GAvBAhN,WA0BA,WACA,IAAAuJ,EApBA,WAGA,IAFA,IAAAe,EAAA,EAEApiB,EAAA,EAAAyB,EAAA2M,EAAA/L,OAAyCrC,EAAAyB,IAAOzB,EAChD,QAAA8oB,EAAAhB,EAAA5H,EAAA9R,EAAApO,GAAAyiB,EAAA,EAAAriB,EAAA8f,EAAA7d,OAAA+R,EAAA8L,EAAA,GAAA6I,EAAA3U,EAAA,GAAA4U,EAAA5U,EAAA,GAAkHqO,EAAAriB,IAAOqiB,EACzHqG,EAAAC,EAAAjB,EAAAkB,EAAA5U,EAAA8L,EAAAuC,GAAAsG,EAAA3U,EAAA,GAAA4U,EAAA5U,EAAA,GACA0T,GAAAR,EAAyB0B,EAAA1B,IAAAyB,EAAAD,IAAAxB,EAAAQ,IAAAkB,EAAAlB,IAAAX,EAAA2B,MAAA1G,EACT4G,GAAA1B,IAAAyB,EAAAD,IAAAxB,EAAAQ,IAAAkB,EAAAlB,IAAAX,EAAA2B,MAAA1G,EAIhB,OAAAA,EASA6G,GACAC,EAAApE,GAAAzD,EACAuE,GAAAzE,EAAgC6C,GAAK7C,IAAA9e,QACrC6mB,GAAAtD,KACA/Q,EAAAgD,eACAqR,IACArU,EAAA8C,YACA2J,EAAA,YAAAzM,GACAA,EAAA+C,WAEAgO,GACUlF,GAAUS,EAAAC,EAAAC,EAAAC,EAAAzM,GAEpBA,EAAAiD,cAEA4Q,EAAA7T,EAAAsM,EAAA/S,EAAA8R,EAAA,OAvCA,SAAA9L,EAAApR,EAAAE,GACA0iB,EAAA5iB,EAAAE,IAAAwlB,EAAAtU,MAAApR,EAAAE,GA8DA,SAAA2lB,EAAA7lB,EAAAE,GACA,IAAAoW,EAAAsM,EAAA5iB,EAAAE,GAEA,GADAkL,GAAA8R,EAAAlY,MAAAhF,EAAAE,IACAulB,EACAN,EAAAnlB,EAAAolB,EAAAllB,EAAAmlB,EAAA/O,EACAmP,GAAA,EACAnP,IACAoP,EAAA/Q,YACA+Q,EAAAtU,MAAApR,EAAAE,SAGA,GAAAoW,GAAAkP,EAAAE,EAAAtU,MAAApR,EAAAE,OACA,CACA,IAAAkJ,GAAAkc,EAAA9lB,KAAAqI,IAAA+c,GAAAplB,KAAAyH,IAAA0d,GAAAW,IAAAC,EAAA/lB,KAAAqI,IAAA+c,GAAAplB,KAAAyH,IAAA0d,GAAAY,KACAlc,GAAArJ,EAAAR,KAAAqI,IAAA+c,GAAAplB,KAAAyH,IAAA0d,GAAA3kB,IAAAE,EAAAV,KAAAqI,IAAA+c,GAAAplB,KAAAyH,IAAA0d,GAAAzkB,KACcgkB,GAAQ9a,EAAAC,EAAA8a,EAAAC,EAAAC,EAAAC,IACtBkB,IACAE,EAAA/Q,YACA+Q,EAAAtU,MAAAhI,EAAA,GAAAA,EAAA,KAEAsc,EAAAtU,MAAA/H,EAAA,GAAAA,EAAA,IACAiN,GAAAoP,EAAA9Q,UACAkN,GAAA,GACWxL,IACXoP,EAAA/Q,YACA+Q,EAAAtU,MAAApR,EAAAE,GACA4hB,GAAA,GAIAwD,EAAAtlB,EAAAulB,EAAArlB,EAAAslB,EAAAlP,EAGA,OAAAsP,GCnKe,ICIXO,GACAC,GACAC,GDNWC,GAAA,WACf,IAIAC,EACAC,EACAhI,EANA2F,EAAA,EACAC,EAAA,EACAC,EAAA,IACAC,EAAA,IAKA,OAAA9F,GACA3M,OAAA,SAAAA,GACA,OAAA0U,GAAAC,IAAA3U,EAAA0U,IAA+D1B,GAAaV,EAAAC,EAAAC,EAAAC,EAAbO,CAAa2B,EAAA3U,IAE5E4U,OAAA,SAAAnJ,GACA,OAAAle,UAAAC,QAAA8kB,GAAA7G,EAAA,MAAA8G,GAAA9G,EAAA,MAAA+G,GAAA/G,EAAA,MAAAgH,GAAAhH,EAAA,MAAAiJ,EAAAC,EAAA,KAAAhI,KAAA2F,EAAAC,IAAAC,EAAAC,OCXAoC,GAAgB5U,IAKhB6U,IACA7S,OAAUT,EACVjC,MAASiC,EACTsB,UAMA,WACAgS,GAAAvV,MAAAwV,GACAD,GAAA/R,QAAAiS,IAPAjS,QAAWvB,EACXwB,aAAgBxB,EAChByB,WAAczB,GAQd,SAAAwT,KACAF,GAAAvV,MAAAuV,GAAA/R,QAA8CvB,EAG9C,SAAAuT,GAAA/Q,EAAAC,GAEEqQ,GADFtQ,GAAYhD,EACQuT,GAAUrT,EADX+C,GAASjD,GACYwT,GAAUtmB,EAAG+V,GACrD6Q,GAAAvV,MAAA0V,GAGA,SAAAA,GAAAjR,EAAAC,GACAD,GAAYhD,EACZ,IAAAsD,EAAepD,EADI+C,GAASjD,GAE5BqD,EAAenW,EAAG+V,GAClB0C,EAAcrQ,EAAG0N,EAAUsQ,IAC3BY,EAAiBhnB,EAAGyY,GAEpBxY,EAAAkW,EADiBnD,EAAGyF,GAEpBtY,EAAUmmB,GAAOlQ,EAAYiQ,GAAOlQ,EAAA6Q,EACpC9mB,EAAUmmB,GAAOjQ,EAAYkQ,GAAOnQ,EAAA6Q,EACpCL,GAAAxU,IAAgBY,EAAMvL,EAAIvH,IAAAE,KAAAD,IACxBkmB,GAAOtQ,EAAWuQ,GAAOjQ,EAAWkQ,GAAOnQ,EAG9B,IAAA8Q,GAAA,SAAAtoB,GAGf,OAFAgoB,GAAA1U,QACEoD,EAAM1W,EAAAioB,KACRD,ICjDIO,IAAW,WACXC,IAAUnlB,KAAA,aAAAiS,YAAiCiT,IAEhCE,GAAA,SAAA/d,EAAAC,GAGf,OAFE4d,GAAW,GAAA7d,EACX6d,GAAW,GAAA5d,EACJ2d,GAAOE,KCJhBE,IACA1T,QAAA,SAAAhV,EAAA0S,GACA,OAAAiW,GAAA3oB,EAAA6U,SAAAnC,IAEAuC,kBAAA,SAAAjV,EAAA0S,GAEA,IADA,IAAAwC,EAAAlV,EAAAkV,SAAA5W,GAAA,EAAAyB,EAAAmV,EAAAvU,SACArC,EAAAyB,GAAA,GAAA4oB,GAAAzT,EAAA5W,GAAAuW,SAAAnC,GAAA,SACA,WAIAkW,IACAzT,OAAA,WACA,UAEAE,MAAA,SAAArV,EAAA0S,GACA,OAAAmW,GAAA7oB,EAAAsV,YAAA5C,IAEA6C,WAAA,SAAAvV,EAAA0S,GAEA,IADA,IAAA4C,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAA,GAAA8oB,GAAAvT,EAAAhX,GAAAoU,GAAA,SACA,UAEA8C,WAAA,SAAAxV,EAAA0S,GACA,OAAAoW,GAAA9oB,EAAAsV,YAAA5C,IAEAgD,gBAAA,SAAA1V,EAAA0S,GAEA,IADA,IAAA4C,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAA,GAAA+oB,GAAAxT,EAAAhX,GAAAoU,GAAA,SACA,UAEA7O,QAAA,SAAA7D,EAAA0S,GACA,OAAAqW,GAAA/oB,EAAAsV,YAAA5C,IAEAkD,aAAA,SAAA5V,EAAA0S,GAEA,IADA,IAAA4C,EAAAtV,EAAAsV,YAAAhX,GAAA,EAAAyB,EAAAuV,EAAA3U,SACArC,EAAAyB,GAAA,GAAAgpB,GAAAzT,EAAAhX,GAAAoU,GAAA,SACA,UAEAmD,mBAAA,SAAA7V,EAAA0S,GAEA,IADA,IAAAoD,EAAA9V,EAAA8V,WAAAxX,GAAA,EAAAyB,EAAA+V,EAAAnV,SACArC,EAAAyB,GAAA,GAAA4oB,GAAA7S,EAAAxX,GAAAoU,GAAA,SACA,WAIA,SAAAiW,GAAA9T,EAAAnC,GACA,SAAAmC,IAAA+T,GAAAzoB,eAAA0U,EAAAxR,QACAulB,GAAA/T,EAAAxR,MAAAwR,EAAAnC,GAIA,SAAAmW,GAAAvT,EAAA5C,GACA,OAAiB,IAAR+V,GAAQnT,EAAA5C,GAGjB,SAAAoW,GAAAxT,EAAA5C,GACA,IAAAsW,EAAWP,GAAQnT,EAAA,GAAAA,EAAA,IAGnB,OAFWmT,GAAQnT,EAAA,GAAA5C,GACR+V,GAAQ/V,EAAA4C,EAAA,KACnB0T,EAAyBnV,EAGzB,SAAAkV,GAAAzT,EAAA5C,GACA,QAAW8N,GAAelL,EAAA3O,IAAAsiB,IAAAC,GAAAxW,IAG1B,SAAAuW,GAAAzK,GACA,OAAAA,IAAA7X,IAAAuiB,KAAAjK,MAAAT,EAGA,SAAA0K,GAAAxW,GACA,OAAAA,EAAA,GAAqByB,EAAOzB,EAAA,GAAayB,GAG1B,IAAAgV,GAAA,SAAAnpB,EAAA0S,GACf,OAAA1S,GAAA0oB,GAAAvoB,eAAAH,EAAAqD,MACAqlB,GAAA1oB,EAAAqD,MACAslB,IAAA3oB,EAAA0S,IC/EA,SAAA0W,GAAA1D,EAAAE,EAAAI,GACA,IAAAxkB,EAAU2gB,GAAKuD,EAAAE,EAAU/R,EAAOmS,GAAAtjB,OAAAkjB,GAChC,gBAAAtkB,GAAsB,OAAAE,EAAAmF,IAAA,SAAAnF,GAA2B,OAAAF,EAAAE,MAGjD,SAAA6nB,GAAA5D,EAAAE,EAAAI,GACA,IAAAzkB,EAAU6gB,GAAKsD,EAAAE,EAAU9R,EAAOkS,GAAArjB,OAAAijB,GAChC,gBAAAnkB,GAAsB,OAAAF,EAAAqF,IAAA,SAAArF,GAA2B,OAAAA,EAAAE,MAGlC,SAAS8nB,KACxB,IAAA3D,EAAAF,EAAA8D,EAAAC,EACA5D,EAAAF,EAAA+D,EAAAC,EAEApoB,EAAAE,EAAAmoB,EAAAC,EADA7D,EAAA,GAAAC,EAAAD,EAAA8D,EAAA,GAAAC,EAAA,IAEArL,EAAA,IAEA,SAAAsL,IACA,OAAY1mB,KAAA,kBAAAiS,YAAAyJ,KAGZ,SAAAA,IACA,OAAWoD,GAAMjU,EAAIsb,EAAAK,KAAAN,EAAAM,GAAAljB,IAAAgjB,GACrBjnB,OAAgByf,GAAMjU,EAAIwb,EAAAI,KAAAL,EAAAK,GAAAnjB,IAAAijB,IAC1BlnB,OAAgByf,GAAMjU,EAAIuX,EAAAM,KAAAJ,EAAAI,GAAA/d,OAAA,SAAA1G,GAA4C,OAAQmI,EAAGnI,EAAAuoB,GAAWhW,IAAUlN,IAAArF,IACtGoB,OAAgByf,GAAMjU,EAAIwX,EAAAM,KAAAJ,EAAAI,GAAAhe,OAAA,SAAAxG,GAA4C,OAAQiI,EAAGjI,EAAAsoB,GAAWjW,IAAUlN,IAAAnF,IAqEtG,OAlEAuoB,EAAAhL,MAAA,WACA,OAAAA,IAAApY,IAAA,SAAA2O,GAA8C,OAASjS,KAAA,aAAAiS,kBAGvDyU,EAAAC,QAAA,WACA,OACA3mB,KAAA,UACAiS,aACAqU,EAAAH,GAAA9mB,OACAknB,EAAAH,GAAArH,MAAA,GACAuH,EAAAJ,GAAAU,UAAA7H,MAAA,GACAwH,EAAAF,GAAAO,UAAA7H,MAAA,OAKA2H,EAAAhC,OAAA,SAAAnJ,GACA,OAAAle,UAAAC,OACAopB,EAAAG,YAAAtL,GAAAuL,YAAAvL,GADAmL,EAAAI,eAIAJ,EAAAG,YAAA,SAAAtL,GACA,OAAAle,UAAAC,QACA6oB,GAAA5K,EAAA,MAAA2K,GAAA3K,EAAA,MACA8K,GAAA9K,EAAA,MAAA6K,GAAA7K,EAAA,MACA4K,EAAAD,IAAA3K,EAAA4K,IAAAD,IAAA3K,GACA8K,EAAAD,IAAA7K,EAAA8K,IAAAD,IAAA7K,GACAmL,EAAAtL,gBALA+K,EAAAE,IAAAH,EAAAE,KAQAM,EAAAI,YAAA,SAAAvL,GACA,OAAAle,UAAAC,QACA8kB,GAAA7G,EAAA,MAAA+G,GAAA/G,EAAA,MACA8G,GAAA9G,EAAA,MAAAgH,GAAAhH,EAAA,MACA6G,EAAAE,IAAA/G,EAAA6G,IAAAE,IAAA/G,GACA8G,EAAAE,IAAAhH,EAAA8G,IAAAE,IAAAhH,GACAmL,EAAAtL,gBALAgH,EAAAC,IAAAC,EAAAC,KAQAmE,EAAA1L,KAAA,SAAAO,GACA,OAAAle,UAAAC,OACAopB,EAAAK,UAAAxL,GAAAyL,UAAAzL,GADAmL,EAAAM,aAIAN,EAAAK,UAAA,SAAAxL,GACA,OAAAle,UAAAC,QACAkpB,GAAAjL,EAAA,GAAAkL,GAAAlL,EAAA,GACAmL,IAFAF,EAAAC,IAKAC,EAAAM,UAAA,SAAAzL,GACA,OAAAle,UAAAC,QACAolB,GAAAnH,EAAA,GAAAoH,GAAApH,EAAA,GACAmL,IAFAhE,EAAAC,IAKA+D,EAAAtL,UAAA,SAAAG,GACA,OAAAle,UAAAC,QACA8d,GAAAG,EACAtd,EAAA8nB,GAAA1D,EAAAE,EAAA,IACApkB,EAAA6nB,GAAA5D,EAAAE,EAAAlH,GACAkL,EAAAP,GAAAM,EAAAD,EAAA,IACAG,EAAAP,GAAAG,EAAAD,EAAA9K,GACAsL,GANAtL,GASAsL,EACAG,eAAA,QAAiCrW,IAAO,OAAcA,KACtDsW,eAAA,QAAiCtW,IAAO,OAAcA,KAG/C,SAAAyW,KACP,OAAShB,OCrGM,ICIXiB,GACAC,GACAC,GACAC,GDPWC,GAAA,SAAAjgB,EAAAC,GACf,IAAA8a,EAAA/a,EAAA,GAAkByJ,EAClBuR,EAAAhb,EAAA,GAAkByJ,EAClBwR,EAAAhb,EAAA,GAAkBwJ,EAClByR,EAAAjb,EAAA,GAAkBwJ,EAClByW,EAAYvpB,EAAGqkB,GACfmF,EAAYxW,EAAGqR,GACfoF,EAAYzpB,EAAGukB,GACfmF,EAAY1W,EAAGuR,GACfoF,EAAAJ,EAAkBvpB,EAAGokB,GACrBwF,EAAAL,EAAkBvW,EAAGoR,GACrByF,EAAAJ,EAAkBzpB,EAAGskB,GACrBwF,EAAAL,EAAkBzW,EAAGsR,GACrB/mB,EAAA,EAAc6V,EAAK5L,EAAK6L,EAAQkR,EAAAF,GAAAkF,EAAAE,EAAwBpW,EAAQiR,EAAAF,KAChE/N,EAAUrD,EAAGzV,GAEbghB,EAAAhhB,EAAA,SAAAY,GACA,IAAA4rB,EAAY/W,EAAG7U,GAAAZ,GAAA8Y,EACfmN,EAAYxQ,EAAGzV,EAAAY,GAAAkY,EACfpW,EAAAujB,EAAAmG,EAAAI,EAAAF,EACA1pB,EAAAqjB,EAAAoG,EAAAG,EAAAD,EACA5pB,EAAAsjB,EAAAgG,EAAAO,EAAAL,EACA,OACM3W,EAAK5S,EAAAF,GAAS4S,EACdE,EAAK7S,EAAIsH,EAAIvH,IAAAE,MAAmB0S,IAEnC,WACH,OAAAuR,EAAiBvR,EAAOwR,EAAOxR,IAK/B,OAFA0L,EAAA6I,SAAA7pB,EAEAghB,GElCeyL,GAAA,SAAA/pB,GACf,OAAAA,GDGIgqB,GAAUlY,IACVmY,GAAcnY,IAMdoY,IACJ9Y,MAASiC,EACTsB,UAAatB,EACbuB,QAAWvB,EACXwB,aAAA,WACIqV,GAAUvV,UAAawV,GACvBD,GAAUtV,QAAWwV,IAEzBtV,WAAA,WACIoV,GAAUvV,UAAauV,GAAUtV,QAAWsV,GAAU9Y,MAASiC,EAC/D2W,GAAO9X,IAAK/J,EAAI8hB,KAChBA,GAAWjY,SAEf4L,OAAA,WACA,IAAAyM,EAAeL,GAAO,EAEtB,OADIA,GAAOhY,QACXqY,IAIA,SAASF,KACPD,GAAU9Y,MAASkZ,GAGrB,SAASA,GAActqB,EAAAE,GACrBgqB,GAAU9Y,MAASmZ,GACnBtB,GAAME,GAAEnpB,EAAMkpB,GAAME,GAAElpB,EAGxB,SAASqqB,GAASvqB,EAAAE,GAChB+pB,GAAW/X,IAAKkX,GAAEppB,EAAOmpB,GAAEjpB,GAC3BipB,GAAEnpB,EAAMopB,GAAElpB,EAGZ,SAASkqB,KACPG,GAAUtB,GAAKC,IAGF,IAAAsB,GAAA,GE/CXC,GAAEtQ,IACFuQ,GAAKD,GACLE,IAAMF,GACNG,GAAKD,GAsBM,ICdXE,GACAC,GACAC,GACAC,GDWWC,IAnBf7Z,MAYA,SAAoBpR,EAAAE,GACpBF,EAAUyqB,KAAIA,GAAEzqB,GAChBA,EAAU2qB,KAAIA,GAAE3qB,GAChBE,EAAUwqB,KAAIA,GAAExqB,GAChBA,EAAU0qB,KAAIA,GAAE1qB,IAfhByU,UAAatB,EACbuB,QAAWvB,EACXwB,aAAgBxB,EAChByB,WAAczB,EACduK,OAAA,WACA,IAAAjT,IAAmB8f,GAAIC,KAAMC,GAAIC,KAEjC,OADID,GAAKC,KAAOF,GAAKD,GAAEtQ,KACvBxP,ICZIugB,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EACFC,GAAE,EAMFC,IACJva,MAASwa,GACTjX,UAAakX,GACbjX,QAAWkX,GACXjX,aAAA,WACI8W,GAAchX,UAAaoX,GAC3BJ,GAAc/W,QAAWoX,IAE7BlX,WAAA,WACI6W,GAAcva,MAASwa,GACvBD,GAAchX,UAAakX,GAC3BF,GAAc/W,QAAWkX,IAE7BlO,OAAA,WACA,IAAAxC,EAAmBsQ,IAAMF,GAAKE,GAAID,GAAKC,IAC7BH,IAAMF,GAAKE,GAAID,GAAKC,IACpBH,IAAMF,GAAKE,GAAID,GAAKC,KAC9BhR,SAIA,OAHI8Q,GAAKC,GAAKC,GACVC,GAAKC,GAAKC,GACVC,GAAKC,GAAKC,GAAE,EAChBtQ,IAIA,SAASwQ,GAAa5rB,EAAAE,GACpBgrB,IAAElrB,EACFmrB,IAAEjrB,IACAkrB,GAGJ,SAASS,KACPF,GAAcva,MAAA6a,GAGhB,SAAAA,GAAAjsB,EAAAE,GACEyrB,GAAcva,MAAA8a,GACdN,GAAcb,GAAE/qB,EAAMgrB,GAAE9qB,GAG1B,SAAAgsB,GAAAlsB,EAAAE,GACA,IAAAukB,EAAAzkB,EAAe+qB,GAAErG,EAAAxkB,EAAW8qB,GAAE/qB,EAAMsH,EAAIkd,IAAAC,KACtC2G,IAAEprB,GAAS8qB,GAAE/qB,GAAA,EACbsrB,IAAErrB,GAAS+qB,GAAE9qB,GAAA,EACbqrB,IAAEtrB,EACF2rB,GAAcb,GAAE/qB,EAAMgrB,GAAE9qB,GAG1B,SAAS4rB,KACPH,GAAcva,MAASwa,GAGzB,SAASG,KACPJ,GAAcva,MAAA+a,GAGhB,SAASH,KACTI,GAAoBvB,GAAKC,IAGzB,SAAAqB,GAAAnsB,EAAAE,GACEyrB,GAAcva,MAAAgb,GACdR,GAAcf,GAAME,GAAE/qB,EAAM8qB,GAAME,GAAE9qB,GAGtC,SAAAksB,GAAApsB,EAAAE,GACA,IAAAukB,EAAAzkB,EAAe+qB,GACfrG,EAAAxkB,EAAe8qB,GACf/qB,EAAUsH,EAAIkd,IAAAC,KAEZ2G,IAAEprB,GAAS8qB,GAAE/qB,GAAA,EACbsrB,IAAErrB,GAAS+qB,GAAE9qB,GAAA,EACbqrB,IAAEtrB,EAGFurB,KADFvrB,EAAM+qB,GAAEhrB,EAAO+qB,GAAE7qB,IACJ6qB,GAAE/qB,GACbyrB,IAAExrB,GAAS+qB,GAAE9qB,GACbwrB,IAAE,EAAAzrB,EACF2rB,GAAcb,GAAE/qB,EAAMgrB,GAAE9qB,GAGX,IAAAmsB,GAAA,GChGA,SAAAC,GAAAppB,GACfH,KAAAwpB,SAAArpB,EAGAopB,GAAA1tB,WACA4tB,QAAA,IACAC,YAAA,SAAAnP,GACA,OAAAva,KAAAypB,QAAAlP,EAAAva,MAEA8R,aAAA,WACA9R,KAAA2pB,MAAA,GAEA5X,WAAA,WACA/R,KAAA2pB,MAAAtS,KAEAzF,UAAA,WACA5R,KAAA4pB,OAAA,GAEA/X,QAAA,WACA,IAAA7R,KAAA2pB,OAAA3pB,KAAAwpB,SAAAxgB,YACAhJ,KAAA4pB,OAAAvS,KAEAhJ,MAAA,SAAApR,EAAAE,GACA,OAAA6C,KAAA4pB,QACA,OACA5pB,KAAAwpB,SAAA3gB,OAAA5L,EAAAE,GACA6C,KAAA4pB,OAAA,EACA,MAEA,OACA5pB,KAAAwpB,SAAA1gB,OAAA7L,EAAAE,GACA,MAEA,QACA6C,KAAAwpB,SAAA3gB,OAAA5L,EAAA+C,KAAAypB,QAAAtsB,GACA6C,KAAAwpB,SAAAhe,IAAAvO,EAAAE,EAAA6C,KAAAypB,QAAA,EAAiD7Z,KAKjDiL,OAAUvK,GCvCV,IACAuZ,GACIC,GACAC,GACAC,GACAC,GALAC,GAAYnb,IAOZob,IACJ9b,MAASiC,EACTsB,UAAA,WACIuY,GAAY9b,MAAS+b,IAEzBvY,QAAA,WACAgY,IAAoBQ,GAAYP,GAAKC,IACjCI,GAAY9b,MAASiC,GAEzBwB,aAAA,WACA+X,IAAA,GAEA9X,WAAA,WACA8X,GAAA,MAEAhP,OAAA,WACA,IAAAve,GAAkB4tB,GAElB,OADIA,GAASjb,QACb3S,IAIA,SAAS8tB,GAAgBntB,EAAAE,GACvBgtB,GAAY9b,MAASgc,GACrBP,GAAME,GAAE/sB,EAAM8sB,GAAME,GAAE9sB,EAGxB,SAASktB,GAAWptB,EAAAE,GAClB6sB,IAAE/sB,EAAOgtB,IAAE9sB,EACX+sB,GAAS/a,IAAK3K,EAAKwlB,GAAKA,GAAKC,GAAKA,KAClCD,GAAE/sB,EAAMgtB,GAAE9sB,EAGG,IAAAmtB,GAAA,GC5CA,SAAAC,KACfvqB,KAAAwqB,WAoDA,SAASC,GAAM/Q,GACf,YAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,eAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,cAAAA,EACA,IArDA6Q,GAAA1uB,WACA4tB,QAAA,IACAiB,QAAWD,GAAM,KACjBf,YAAA,SAAAnP,GAEA,OADAA,QAAAva,KAAAypB,UAAAzpB,KAAAypB,QAAAlP,EAAAva,KAAA0qB,QAAA,MACA1qB,MAEA8R,aAAA,WACA9R,KAAA2pB,MAAA,GAEA5X,WAAA,WACA/R,KAAA2pB,MAAAtS,KAEAzF,UAAA,WACA5R,KAAA4pB,OAAA,GAEA/X,QAAA,WACA,IAAA7R,KAAA2pB,OAAA3pB,KAAAwqB,QAAAvoB,KAAA,KACAjC,KAAA4pB,OAAAvS,KAEAhJ,MAAA,SAAApR,EAAAE,GACA,OAAA6C,KAAA4pB,QACA,OACA5pB,KAAAwqB,QAAAvoB,KAAA,IAAAhF,EAAA,IAAAE,GACA6C,KAAA4pB,OAAA,EACA,MAEA,OACA5pB,KAAAwqB,QAAAvoB,KAAA,IAAAhF,EAAA,IAAAE,GACA,MAEA,QACA,MAAA6C,KAAA0qB,UAAA1qB,KAAA0qB,QAAiDD,GAAMzqB,KAAAypB,UACvDzpB,KAAAwqB,QAAAvoB,KAAA,IAAAhF,EAAA,IAAAE,EAAA6C,KAAA0qB,WAKA7P,OAAA,WACA,GAAA7a,KAAAwqB,QAAAluB,OAAA,CACA,IAAAue,EAAA7a,KAAAwqB,QAAAzgB,KAAA,IAEA,OADA/J,KAAAwqB,WACA3P,EAEA,cCvCA,IAAA8P,GAAA,SAAeC,EAAAzqB,GACf,IACA0qB,EACAC,EAFApB,EAAA,IAIA,SAAAnb,EAAA5S,GAKA,OAJAA,IACA,mBAAA+tB,GAAAoB,EAAApB,eAAApP,MAAAta,KAAA3D,YACMgW,EAAM1W,EAAAkvB,EAAAC,KAEZA,EAAAjQ,SAwCA,OArCAtM,EAAA+Y,KAAA,SAAA3rB,GAEA,OADI0W,EAAM1W,EAAAkvB,EAA0BpD,KACzBA,GAAQ5M,UAGnBtM,EAAA+b,QAAA,SAAA3uB,GAEA,OADI0W,EAAM1W,EAAAkvB,EAA0BP,KACzBA,GAAWzP,UAGtBtM,EAAA3G,OAAA,SAAAjM,GAEA,OADI0W,EAAM1W,EAAAkvB,EAA0B3C,KACzBA,GAAUrN,UAGrBtM,EAAA8J,SAAA,SAAA1c,GAEA,OADI0W,EAAM1W,EAAAkvB,EAA0BvB,KACzBA,GAAYzO,UAGvBtM,EAAAqc,WAAA,SAAArQ,GACA,OAAAle,UAAAC,QAAAuuB,EAAA,MAAAtQ,GAAAqQ,EAAA,KAAkF5D,KAAQ4D,EAAArQ,GAAAzL,OAAAP,GAAAqc,GAG1Frc,EAAApO,QAAA,SAAAoa,GACA,OAAAle,UAAAC,QACAwuB,EAAA,MAAAvQ,GAAApa,EAAA,SAAqDoqB,IAAU,IAAQhB,GAAWppB,EAAAoa,GAClF,mBAAAmP,GAAAoB,EAAApB,eACAnb,GAHApO,GAMAoO,EAAAmb,YAAA,SAAAnP,GACA,OAAAle,UAAAC,QACAotB,EAAA,mBAAAnP,KAAAuQ,EAAApB,aAAAnP,OACAhM,GAFAmb,GAKAnb,EAAAqc,cAAAzqB,YC3De4qB,GAAA,SAAAC,GACf,OACAlc,OAAAmc,GAAAD,KAIO,SAAAC,GAAAD,GACP,gBAAAlc,GACA,IAAA9S,EAAA,IAAAkvB,GACA,QAAA1vB,KAAAwvB,EAAAhvB,EAAAR,GAAAwvB,EAAAxvB,GAEA,OADAQ,EAAA8S,SACA9S,GAIA,SAAAkvB,MCZA,SAAAC,GAAAP,EAAAQ,EAAAzvB,GACA,IAAA8f,EAAAmP,EAAAS,YAAAT,EAAAS,aAMA,OALAT,EAAAlpB,MAAA,KAAA4pB,WAAA,MACA,MAAA7P,GAAAmP,EAAAS,WAAA,MACEhZ,EAAS1W,EAAAivB,EAAA9b,OAA2BoZ,KACtCkD,EAAYlD,GAAYrN,UACxB,MAAAY,GAAAmP,EAAAS,WAAA5P,GACAmP,EAGO,SAAAW,GAAAX,EAAAlH,EAAA/nB,GACP,OAAAwvB,GAAAP,EAAA,SAAAtkB,GACA,IAAAyR,EAAA2L,EAAA,MAAAA,EAAA,MACA8H,EAAA9H,EAAA,MAAAA,EAAA,MACArQ,EAAA5W,KAAAyH,IAAA6T,GAAAzR,EAAA,MAAAA,EAAA,OAAAklB,GAAAllB,EAAA,MAAAA,EAAA,QACArJ,GAAAymB,EAAA,OAAA3L,EAAA1E,GAAA/M,EAAA,MAAAA,EAAA,UACAnJ,GAAAumB,EAAA,OAAA8H,EAAAnY,GAAA/M,EAAA,MAAAA,EAAA,UACAskB,EAAAlpB,MAAA,IAAA2R,GAAAiY,WAAAruB,EAAAE,KACGxB,GAGI,SAAA8vB,GAAAb,EAAAnf,EAAA9P,GACP,OAAA4vB,GAAAX,IAAA,KAAAnf,GAAA9P,GAGO,SAAA+vB,GAAAd,EAAA9pB,EAAAnF,GACP,OAAAwvB,GAAAP,EAAA,SAAAtkB,GACA,IAAAyR,GAAAjX,EACAuS,EAAA0E,GAAAzR,EAAA,MAAAA,EAAA,OACArJ,GAAA8a,EAAA1E,GAAA/M,EAAA,MAAAA,EAAA,UACAnJ,GAAAkW,EAAA/M,EAAA,MACAskB,EAAAlpB,MAAA,IAAA2R,GAAAiY,WAAAruB,EAAAE,KACGxB,GAGI,SAAAgwB,GAAAf,EAAA7pB,EAAApF,GACP,OAAAwvB,GAAAP,EAAA,SAAAtkB,GACA,IAAAklB,GAAAzqB,EACAsS,EAAAmY,GAAAllB,EAAA,MAAAA,EAAA,OACArJ,GAAAoW,EAAA/M,EAAA,MACAnJ,GAAAquB,EAAAnY,GAAA/M,EAAA,MAAAA,EAAA,UACAskB,EAAAlpB,MAAA,IAAA2R,GAAAiY,WAAAruB,EAAAE,KACGxB,GD5BHuvB,GAAArvB,WACAqT,YAAAgc,GACA7c,MAAA,SAAApR,EAAAE,GAAyB6C,KAAA8O,OAAAT,MAAApR,EAAAE,IACzB4T,OAAA,WAAsB/Q,KAAA8O,OAAAiC,UACtBa,UAAA,WAAyB5R,KAAA8O,OAAA8C,aACzBC,QAAA,WAAuB7R,KAAA8O,OAAA+C,WACvBC,aAAA,WAA4B9R,KAAA8O,OAAAgD,gBAC5BC,WAAA,WAA0B/R,KAAA8O,OAAAiD,eEpB1B,IAAA6Z,GAAA,GACAC,GAAqB7uB,EAAG,GAAM8S,GAEfgc,GAAA,SAAAC,EAAAC,GACf,OAAAA,EAYA,SAAiBD,EAAAC,GAEjB,SAAAC,EAAA7K,EAAAC,EAAAxL,EAAAkN,EAAAC,EAAAjC,EAAAO,EAAAC,EAAAzL,EAAAiM,EAAAkB,EAAA5C,EAAA6L,EAAApd,GACA,IAAA4S,EAAAJ,EAAAF,EACAO,EAAAJ,EAAAF,EACA8K,EAAAzK,IAAAC,IACA,GAAAwK,EAAA,EAAAH,GAAAE,IAAA,CACA,IAAA7lB,EAAA0c,EAAAhB,EACAzb,EAAA0c,EAAAC,EACA3oB,EAAAymB,EAAAV,EACAhmB,EAAcmK,EAAI6B,IAAAC,IAAAhM,KAClB8xB,EAAiBhc,EAAI9V,GAAAD,GACrBgyB,EAAoBjnB,EAAIA,EAAG9K,GAAA,GAAWkV,GAAWpK,EAAGyQ,EAAAC,GAAsBtG,GAAOqG,EAAAC,GAAA,EAA6B/F,EAAKzJ,EAAAD,GACnHtK,EAAAgwB,EAAAM,EAAAD,GACAE,EAAAvwB,EAAA,GACAwwB,EAAAxwB,EAAA,GACAywB,EAAAF,EAAAlL,EACAqL,EAAAF,EAAAlL,EACAqL,EAAA/K,EAAA6K,EAAA9K,EAAA+K,GACAC,IAAAP,EAAAH,GACa5mB,GAAGsc,EAAA8K,EAAA7K,EAAA8K,GAAAN,EAAA,QAChBpJ,EAAAhB,EAAAiB,EAAAC,EAAAlC,EAAAV,EAAAwL,MACAI,EAAA7K,EAAAC,EAAAxL,EAAAkN,EAAAC,EAAAjC,EAAAuL,EAAAC,EAAAF,EAAAhmB,GAAAhM,EAAAiM,GAAAjM,EAAAC,EAAA4xB,EAAApd,GACAA,EAAAT,MAAAie,EAAAC,GACAN,EAAAK,EAAAC,EAAAF,EAAAhmB,EAAAC,EAAAhM,EAAAgnB,EAAAC,EAAAzL,EAAAiM,EAAAkB,EAAA5C,EAAA6L,EAAApd,KAIA,gBAAAA,GACA,IAAA6d,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAnX,EAAAuL,EAAAC,EAAA0B,EAAAC,EAAAjC,EAEAkM,GACA5e,QACAuD,YACAC,UACAC,aAAA,WAAgChD,EAAAgD,eAAuBmb,EAAArb,UAAA+M,GACvD5M,WAAA,WAA8BjD,EAAAiD,aAAqBkb,EAAArb,cAGnD,SAAAvD,EAAApR,EAAAE,GACAF,EAAA8uB,EAAA9uB,EAAAE,GACA2R,EAAAT,MAAApR,EAAA,GAAAA,EAAA,IAGA,SAAA2U,IACAwP,EAAA/J,IACA4V,EAAA5e,MAAAyU,EACAhU,EAAA8C,YAGA,SAAAkR,EAAAhQ,EAAAC,GACA,IAAAzY,EAAcqZ,GAASb,EAAAC,IAAAhX,EAAAgwB,EAAAjZ,EAAAC,GACvBkZ,EAAA7K,EAAAC,EAAAxL,EAAAkN,EAAAC,EAAAjC,EAAAK,EAAArlB,EAAA,GAAAslB,EAAAtlB,EAAA,GAAA8Z,EAAA/C,EAAAiQ,EAAAzoB,EAAA,GAAA0oB,EAAA1oB,EAAA,GAAAymB,EAAAzmB,EAAA,GAAAsxB,GAAA9c,GACAA,EAAAT,MAAA+S,EAAAC,GAGA,SAAAxP,IACAob,EAAA5e,QACAS,EAAA+C,UAGA,SAAA8M,IACA/M,IACAqb,EAAA5e,MAAA6e,EACAD,EAAApb,QAAA+M,EAGA,SAAAsO,EAAApa,EAAAC,GACA+P,EAAA6J,EAAA7Z,EAAAC,GAAA6Z,EAAAxL,EAAAyL,EAAAxL,EAAAyL,EAAA/J,EAAAgK,EAAA/J,EAAAgK,EAAAjM,EACAkM,EAAA5e,MAAAyU,EAGA,SAAAlE,IACAqN,EAAA7K,EAAAC,EAAAxL,EAAAkN,EAAAC,EAAAjC,EAAA6L,EAAAC,EAAAF,EAAAG,EAAAC,EAAAC,EAAApB,GAAA9c,GACAme,EAAApb,UACAA,IAGA,OAAAob,GA3FmBE,CAAQpB,EAAAC,GAG3B,SAAAD,GACA,OAASd,IACT5c,MAAA,SAAApR,EAAAE,GACAF,EAAA8uB,EAAA9uB,EAAAE,GACA6C,KAAA8O,OAAAT,MAAApR,EAAA,GAAAA,EAAA,OAP2BmwB,CAAArB,ICG3B,IAAAsB,GAAuBpC,IACvB5c,MAAA,SAAApR,EAAAE,GACA6C,KAAA8O,OAAAT,MAAApR,EAA0B6S,EAAO3S,EAAM2S,MAuBvC,SAAAwd,GAAAja,EAAAqO,EAAAC,EAAA4L,GACA,IAAAC,EAAiBxwB,EAAGuwB,GACpBE,EAAiBzd,EAAGud,GACpBlnB,EAAAmnB,EAAAna,EACA/M,EAAAmnB,EAAApa,EACAqa,EAAAF,EAAAna,EACAsa,EAAAF,EAAApa,EACAua,GAAAH,EAAA9L,EAAA6L,EAAA9L,GAAArO,EACAwa,GAAAJ,EAAA/L,EAAA8L,EAAA7L,GAAAtO,EACA,SAAAjG,EAAAnQ,EAAAE,GACA,OAAAkJ,EAAApJ,EAAAqJ,EAAAnJ,EAAAukB,EAAAC,EAAArb,EAAArJ,EAAAoJ,EAAAlJ,GAKA,OAHAiQ,EAAAoL,OAAA,SAAAvb,EAAAE,GACA,OAAAuwB,EAAAzwB,EAAA0wB,EAAAxwB,EAAAywB,EAAAC,EAAAF,EAAA1wB,EAAAywB,EAAAvwB,IAEAiQ,EAGe,SAAS0gB,GAAU/B,GAClC,OAAAgC,GAAA,WAAuC,OAAAhC,GAAvCgC,GAGO,SAAAA,GAAAC,GACP,IAAAjC,EAIAxS,EAGA8H,EAAAC,EAAAC,EAEA0M,EACAC,EACAC,EACA3K,EACAC,EAZApQ,EAAA,IACApW,EAAA,IAAAE,EAAA,IACA2V,EAAA,EAAAC,EAAA,EACA4F,EAAA,EAAAC,EAAA,EAAAC,EAAA,EACA0U,EAAA,EACAa,EAAA,KAAAC,EAA8BnP,GAC9BkC,EAAA,KAAAkN,EAAwCtH,GACxCgF,EAAA,GAOA,SAAApB,EAAAvc,GACA,OAAA8f,EAAA9f,EAAA,GAA6CyB,EAAOzB,EAAA,GAAayB,GAGjE,SAAA0I,EAAAnK,GAEA,OADAA,EAAA8f,EAAA3V,OAAAnK,EAAA,GAAAA,EAAA,OACAA,EAAA,GAAgCwB,EAAOxB,EAAA,GAAawB,GA+DpD,SAAA0e,IACA,IAAA5wB,EAAA2vB,GAAAja,EAAA,IAAAka,GAAAjT,MAAA,KAAAyR,EAAAjZ,EAAAC,IACA3F,GAAAmgB,EAAAD,GAvHA,SAAAja,EAAAqO,EAAAC,GACA,SAAAvU,EAAAnQ,EAAAE,GACA,OAAAukB,EAAArO,EAAApW,EAAA0kB,EAAAtO,EAAAlW,GAKA,OAHAiQ,EAAAoL,OAAA,SAAAvb,EAAAE,GACA,QAAAF,EAAAykB,GAAArO,GAAAsO,EAAAxkB,GAAAkW,IAEAjG,IAgHAiG,EAAApW,EAAAU,EAAA,GAAAR,EAAAQ,EAAA,GAAA4vB,GAKA,OAJAhU,EAAab,GAAaC,EAAAC,EAAAC,GAC1BqV,EAAuB3V,GAAOwT,EAAA3e,GAC9B+gB,EAA6B5V,GAAOgB,EAAA2U,GACpCD,EAAsBnC,GAAQoC,EAAAlC,GAC9B/c,IAGA,SAAAA,IAEA,OADAuU,EAAAC,EAAA,KACAmH,EAGA,OA3EAA,EAAA9b,OAAA,SAAAA,GACA,OAAA0U,GAAAC,IAAA3U,EAAA0U,IAAA6J,GAnEA,SAAA9T,GACA,OAAS0R,IACT5c,MAAA,SAAApR,EAAAE,GACA,IAAApC,EAAAwe,EAAAtc,EAAAE,GACA,OAAA6C,KAAA8O,OAAAT,MAAAtT,EAAA,GAAAA,EAAA,OA+DAyzB,CAAAjV,EAAAiV,CAAAH,EAAAJ,EAAAK,EAAA7K,EAAA3U,QAGA8b,EAAAyD,QAAA,SAAA9T,GACA,OAAAle,UAAAC,QAAA+xB,EAAA9T,EAAA6T,OAAA7xB,EAAA0S,KAAAof,GAGAzD,EAAA0D,SAAA,SAAA/T,GACA,OAAAle,UAAAC,QAAAgyB,EAAA/T,EAAA6G,EAAAC,EAAAC,EAAAC,EAAA,KAAAtS,KAAAqf,GAGA1D,EAAA6D,UAAA,SAAAlU,GACA,OAAAle,UAAAC,QAAA+xB,GAAA9T,EAA8CkF,GAAU2O,EAAA7T,EAAazK,IAAOse,EAAA,KAAmBlP,IAAgBjQ,KAAAmf,EAAsBve,GAGrI+a,EAAAS,WAAA,SAAA9Q,GACA,OAAAle,UAAAC,QAAAgyB,EAAA,MAAA/T,GAAA6G,EAAAC,EAAAC,EAAAC,EAAA,KAAiFyF,IAAYlF,GAAaV,GAAA7G,EAAA,MAAA8G,GAAA9G,EAAA,MAAA+G,GAAA/G,EAAA,MAAAgH,GAAAhH,EAAA,OAAAtL,KAAA,MAAAmS,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAG1GqJ,EAAAlpB,MAAA,SAAA6Y,GACA,OAAAle,UAAAC,QAAA+W,GAAAkH,EAAAgU,KAAAlb,GAGAuX,EAAAU,UAAA,SAAA/Q,GACA,OAAAle,UAAAC,QAAAW,GAAAsd,EAAA,GAAApd,GAAAod,EAAA,GAAAgU,MAAAtxB,EAAAE,IAGAytB,EAAAjtB,OAAA,SAAA4c,GACA,OAAAle,UAAAC,QAAAwW,EAAAyH,EAAA,OAAqDzK,EAAOiD,EAAAwH,EAAA,OAAqBzK,EAAOye,MAAAzb,EAA0BjD,EAAOkD,EAAQlD,IAGjI+a,EAAArR,OAAA,SAAAgB,GACA,OAAAle,UAAAC,QAAAqc,EAAA4B,EAAA,OAA0DzK,EAAO8I,EAAA2B,EAAA,OAA0BzK,EAAO+I,EAAA0B,EAAAje,OAAA,EAAAie,EAAA,OAA2CzK,EAAO,EAAAye,MAAA5V,EAAmC9I,EAAO+I,EAAa/I,EAAOgJ,EAAehJ,IAGjO+a,EAAAxO,MAAA,SAAA7B,GACA,OAAAle,UAAAC,QAAAixB,EAAAhT,EAAA,IAAiDzK,EAAOye,KAAAhB,EAAwB1d,GAGhF+a,EAAAxQ,UAAA,SAAAG,GACA,OAAAle,UAAAC,QAAA2xB,EAAiDnC,GAAQoC,EAAAlC,EAAAzR,KAAAtL,KAA+CzK,EAAIwnB,IAG5GpB,EAAAW,UAAA,SAAA7H,EAAA/nB,GACA,OAAW4vB,GAASX,EAAAlH,EAAA/nB,IAGpBivB,EAAAa,QAAA,SAAAhgB,EAAA9P,GACA,OAAW8vB,GAAOb,EAAAnf,EAAA9P,IAGlBivB,EAAAc,SAAA,SAAA5qB,EAAAnF,GACA,OAAW+vB,GAAQd,EAAA9pB,EAAAnF,IAGnBivB,EAAAe,UAAA,SAAA5qB,EAAApF,GACA,OAAWgwB,GAASf,EAAA7pB,EAAApF,IAkBpB,WAGA,OAFAowB,EAAAiC,EAAA1T,MAAAta,KAAA3D,WACAuuB,EAAApS,OAAAuT,EAAAvT,UACA+V,KC9JO,SAAAG,GAAAV,GACP,IAAAzR,EAAA,EACAO,EAAarN,EAAE,EACfpV,EAAU0zB,GAAiBC,GAC3BjyB,EAAA1B,EAAAkiB,EAAAO,GAMA,OAJA/gB,EAAA4yB,UAAA,SAAApU,GACA,OAAAle,UAAAC,OAAAjC,EAAAkiB,EAAAhC,EAAA,GAA8CzK,EAAOgN,EAAAvC,EAAA,GAAgBzK,IAAOyM,EAAY1M,EAAOiN,EAASjN,IAGxG9T,ECTO,SAAA6yB,GAAAvN,EAAAE,GACP,IAAAiF,EAAYxW,EAAGqR,GAAA3lB,GAAA8qB,EAAiBxW,EAAGuR,IAAA,EAGnC,GAAMnc,EAAG1J,GAAM8T,EAAO,OCNf,SAAA+M,GACP,IAAAE,EAAgBzf,EAAGuf,GAEnB,SAAA/C,EAAA1G,EAAAC,GACA,OAAAD,EAAA2J,EAA8BzM,EAAG+C,GAAA0J,GAOjC,OAJAjD,EAAAhB,OAAA,SAAAvb,EAAAE,GACA,OAAAF,EAAAwf,EAAyBrM,EAAIjT,EAAAsf,KAG7BjD,EDL+BqV,CAAuBxN,GAEtD,IAAA/mB,EAAA,EAAAksB,GAAA,EAAA9qB,EAAA8qB,GAAAsI,EAAwCtqB,EAAIlK,GAAAoB,EAE5C,SAAAqwB,EAAA9uB,EAAAE,GACA,IAAApC,EAAYyJ,EAAIlK,EAAA,EAAAoB,EAAasU,EAAG7S,IAAAzB,EAChC,OAAAX,EAAgBiV,EAAG/S,GAAAvB,GAAAozB,EAAA/zB,EAAmBiC,EAAGC,IAQzC,OALA8uB,EAAAvT,OAAA,SAAAvb,EAAAE,GACA,IAAA4xB,EAAAD,EAAA3xB,EACA,OAAY4S,EAAK9S,EAAImI,EAAG2pB,IAAArzB,EAAauU,EAAI8e,GAAO3e,GAAI9V,GAAA2C,IAAA8xB,KAAArzB,MAAA,EAAAA,MAGpDqwB,EAGe,IAAAiD,GAAA,WACf,OAASN,GAAeE,IACxBltB,MAAA,SACA/D,QAAA,aE1BesxB,GAAA,WACf,OAASD,KACTL,WAAA,YACAjtB,MAAA,MACA4pB,WAAA,UACA/R,QAAA,OACA5b,SAAA,WCgBe,IAAAuxB,GAAA,WACf,IAAA1L,EACAC,EACsB0L,EACOC,EACAC,EAC7BhhB,EAHAihB,EAAgBL,KAChBM,EAAeP,KAAczV,QAAA,QAAA5b,SAAA,SAAAgxB,WAAA,QAC7Ba,EAAeR,KAAczV,QAAA,QAAA5b,SAAA,SAAAgxB,WAAA,OAC7Bc,GAA4BphB,MAAA,SAAApR,EAAAE,GAAuBkR,GAAApR,EAAAE,KAEnD,SAAAuyB,EAAAze,GACA,IAAAhU,EAAAgU,EAAA,GAAA9T,EAAA8T,EAAA,GACA,OAAA5C,EAAA,KACA8gB,EAAA9gB,MAAApR,EAAAE,GAAAkR,IACA+gB,EAAA/gB,MAAApR,EAAAE,GAAAkR,KACAghB,EAAAhhB,MAAApR,EAAAE,GAAAkR,GAmEA,SAAAY,IAEA,OADAuU,EAAAC,EAAA,KACAiM,EAGA,OArEAA,EAAAlX,OAAA,SAAAvH,GACA,IAAAoC,EAAAic,EAAA5tB,QACAvG,EAAAm0B,EAAAhE,YACAruB,GAAAgU,EAAA,GAAA9V,EAAA,IAAAkY,EACAlW,GAAA8T,EAAA,GAAA9V,EAAA,IAAAkY,EACA,OAAAlW,GAAA,KAAAA,EAAA,MAAAF,IAAA,MAAAA,GAAA,KAAAsyB,EACApyB,GAAA,MAAAA,EAAA,MAAAF,IAAA,MAAAA,GAAA,KAAAuyB,EACAF,GAAA9W,OAAAvH,IAGAye,EAAA5gB,OAAA,SAAAA,GACA,OAAA0U,GAAAC,IAAA3U,EAAA0U,IA5CA,SAAAmM,GACA,IAAAj0B,EAAAi0B,EAAArzB,OACA,OACA+R,MAAA,SAAApR,EAAAE,GAAuC,IAAZ,IAAAlD,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAAoU,MAAApR,EAAAE,IACvC4T,OAAA,WAAoC,IAAZ,IAAA9W,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAA8W,UACpCa,UAAA,WAAuC,IAAZ,IAAA3X,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAA2X,aACvCC,QAAA,WAAqC,IAAZ,IAAA5X,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAA4X,WACrCC,aAAA,WAA0C,IAAZ,IAAA7X,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAA6X,gBAC1CC,WAAA,WAAwC,IAAZ,IAAA9X,GAAA,IAAYA,EAAAyB,GAAAi0B,EAAA11B,GAAA8X,eAoCxC6d,EAAAN,EAAAxgB,OAAA2U,EAAA3U,GAAAygB,EAAAzgB,UAAA0gB,EAAA1gB,aAGA4gB,EAAAtV,UAAA,SAAAG,GACA,OAAAle,UAAAC,QACAgzB,EAAAlV,UAAAG,GAAAgV,EAAAnV,UAAAG,GAAAiV,EAAApV,UAAAG,GACAtL,KAFAqgB,EAAAlV,aAKAsV,EAAAhuB,MAAA,SAAA6Y,GACA,OAAAle,UAAAC,QACAgzB,EAAA5tB,MAAA6Y,GAAAgV,EAAA7tB,MAAA,IAAA6Y,GAAAiV,EAAA9tB,MAAA6Y,GACAmV,EAAApE,UAAAgE,EAAAhE,cAFAgE,EAAA5tB,SAKAguB,EAAApE,UAAA,SAAA/Q,GACA,IAAAle,UAAAC,OAAA,OAAAgzB,EAAAhE,YACA,IAAAjY,EAAAic,EAAA5tB,QAAAzE,GAAAsd,EAAA,GAAApd,GAAAod,EAAA,GAiBA,OAfA4U,EAAAG,EACAhE,UAAA/Q,GACA8Q,aAAApuB,EAAA,KAAAoW,EAAAlW,EAAA,KAAAkW,IAAApW,EAAA,KAAAoW,EAAAlW,EAAA,KAAAkW,KACAvE,OAAA2gB,GAEAL,EAAAG,EACAjE,WAAAruB,EAAA,KAAAoW,EAAAlW,EAAA,KAAAkW,IACAgY,aAAApuB,EAAA,KAAAoW,EAAsC7D,EAAOrS,EAAA,IAAAkW,EAAkB7D,IAAOvS,EAAA,KAAAoW,EAAoB7D,EAAOrS,EAAA,KAAAkW,EAAkB7D,KACnHV,OAAA2gB,GAEAJ,EAAAG,EACAlE,WAAAruB,EAAA,KAAAoW,EAAAlW,EAAA,KAAAkW,IACAgY,aAAApuB,EAAA,KAAAoW,EAAsC7D,EAAOrS,EAAA,KAAAkW,EAAkB7D,IAAOvS,EAAA,KAAAoW,EAAoB7D,EAAOrS,EAAA,KAAAkW,EAAkB7D,KACnHV,OAAA2gB,GAEAxgB,KAGAygB,EAAAnE,UAAA,SAAA7H,EAAA/nB,GACA,OAAW4vB,GAASmE,EAAAhM,EAAA/nB,IAGpB+zB,EAAAjE,QAAA,SAAAhgB,EAAA9P,GACA,OAAW8vB,GAAOiE,EAAAjkB,EAAA9P,IAGlB+zB,EAAAhE,SAAA,SAAA5qB,EAAAnF,GACA,OAAW+vB,GAAQgE,EAAA5uB,EAAAnF,IAGnB+zB,EAAA/D,UAAA,SAAA5qB,EAAApF,GACA,OAAWgwB,GAAS+D,EAAA3uB,EAAApF,IAQpB+zB,EAAAhuB,MAAA,OC3GO,SAAAmuB,GAAAnuB,GACP,gBAAAzE,EAAAE,GACA,IAAA+a,EAAalb,EAAGC,GAChBkb,EAAanb,EAAGG,GAChBkW,EAAA3R,EAAAwW,EAAAC,GACA,OACA9E,EAAA8E,EAAenI,EAAG/S,GAClBoW,EAAUrD,EAAG7S,KAKN,SAAA2yB,GAAA1T,GACP,gBAAAnf,EAAAE,GACA,IAAAD,EAAYsH,EAAIvH,IAAAE,KAChB7C,EAAA8hB,EAAAlf,GACA6yB,EAAa/f,EAAG1V,GAChB01B,EAAahzB,EAAG1C,GAChB,OACMyV,EAAK9S,EAAA8yB,EAAA7yB,EAAA8yB,GACL5f,EAAIlT,GAAAC,EAAA4yB,EAAA7yB,KClBH,IAAA+yB,GAA4BJ,GAAY,SAAAK,GAC/C,OAAS1rB,EAAI,KAAA0rB,MAGbD,GAAAzX,OAA+BsX,GAAe,SAAA5yB,GAC9C,SAAakT,EAAIlT,EAAA,KAGF,IAAAizB,GAAA,WACf,OAASrC,GAAUmC,IACnBvuB,MAAA,QACA+sB,UAAA,UCXO2B,GAA8BP,GAAY,SAAAv1B,GACjD,OAAAA,EAAc6V,EAAI7V,OAAY0V,EAAG1V,KAGjC81B,GAAA5X,OAAiCsX,GAAe,SAAA5yB,GAChD,OAAAA,IAGe,IAAAmzB,GAAA,WACf,OAASvC,GAAUsC,IACnB1uB,MAAA,SACA+sB,UAAA,UCXO,SAAA6B,GAAAxd,EAAAC,GACP,OAAAD,EAAkBjW,EAAIC,GAAK4S,EAAMqD,GAAA,KAGjCud,GAAA9X,OAAA,SAAAvb,EAAAE,GACA,OAAAF,EAAA,EAAiBG,EAAKC,EAAGF,IAAOuS,IAGjB,IAAA6gB,GAAA,WACf,OAAAC,GAAAF,IACA5uB,MAAA,IAAmBkO,IAGZ,SAAA4gB,GAAAzE,GACP,IAKA1K,EAAAC,EAAAC,EALAlnB,EAAUyzB,GAAU/B,GACpBpuB,EAAAtD,EAAAsD,OACA+D,EAAArH,EAAAqH,MACA4pB,EAAAjxB,EAAAixB,UACAD,EAAAhxB,EAAAgxB,WACAjK,EAAA,KAkBA,SAAAqP,IACA,IAAApd,EAAY5D,EAAE/N,IACdvG,EAAAd,EAAcif,GAAQjf,EAAAkf,UAAAf,QAAA,OACtB,OAAA6S,EAAA,MAAAjK,IACAjmB,EAAA,GAAAkY,EAAAlY,EAAA,GAAAkY,IAAAlY,EAAA,GAAAkY,EAAAlY,EAAA,GAAAkY,IAAA0Y,IAAAuE,KACA7zB,KAAAqI,IAAA3J,EAAA,GAAAkY,EAAA+N,GAAAC,IAAA5kB,KAAAyH,IAAA/I,EAAA,GAAAkY,EAAAiO,GAAAC,MACAH,EAAA3kB,KAAAqI,IAAA3J,EAAA,GAAAkY,EAAAgO,KAAAC,EAAA7kB,KAAAyH,IAAA/I,EAAA,GAAAkY,EAAAkO,MAGA,OAzBAlnB,EAAAqH,MAAA,SAAA6Y,GACA,OAAAle,UAAAC,QAAAoF,EAAA6Y,GAAAkW,KAAA/uB,KAGArH,EAAAixB,UAAA,SAAA/Q,GACA,OAAAle,UAAAC,QAAAgvB,EAAA/Q,GAAAkW,KAAAnF,KAGAjxB,EAAAsD,OAAA,SAAA4c,GACA,OAAAle,UAAAC,QAAAqB,EAAA4c,GAAAkW,KAAA9yB,KAGAtD,EAAAgxB,WAAA,SAAA9Q,GACA,OAAAle,UAAAC,QAAA,MAAAie,EAAA6G,EAAAC,EAAAC,EAAAC,EAAA,MAAAH,GAAA7G,EAAA,MAAA8G,GAAA9G,EAAA,MAAA+G,GAAA/G,EAAA,MAAAgH,GAAAhH,EAAA,OAAAkW,KAAA,MAAArP,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAYAkP,IC9CA,SAAAC,GAAAvzB,GACA,OAASL,GAAK4S,EAAMvS,GAAA,GAGb,SAAAwzB,GAAAtP,EAAAE,GACP,IAAAgF,EAAYvpB,EAAGqkB,GACf3lB,EAAA2lB,IAAAE,EAAsBvR,EAAGqR,GAAOxkB,EAAG0pB,EAAOvpB,EAAGukB,IAAQ1kB,EAAG6zB,GAAAnP,GAAAmP,GAAArP,IACxDhE,EAAAkJ,EAAgB7pB,EAAGg0B,GAAArP,GAAA3lB,KAEnB,IAAAA,EAAA,OAAiB40B,GAEjB,SAAAvE,EAAA9uB,EAAAE,GACAkgB,EAAA,EAAgBlgB,GAAUuS,EAASF,IAAOrS,GAAOuS,EAASF,GAChDrS,EAASuS,EAASF,IAAOrS,EAAMuS,EAASF,GAClD,IAAAzU,EAAAsiB,EAAgB3gB,EAAGg0B,GAAAvzB,GAAAzB,GACnB,OAAAX,EAAgBiV,EAAGtU,EAAAuB,GAAAogB,EAAAtiB,EAAiBiC,EAAGtB,EAAAuB,IAQvC,OALA8uB,EAAAvT,OAAA,SAAAvb,EAAAE,GACA,IAAAyzB,EAAAvT,EAAAlgB,EAAApC,EAAwBkV,EAAIvU,GAAM8I,EAAIvH,IAAA2zB,KACtC,OAAY7gB,EAAK9S,EAAImI,EAAGwrB,IAAAl1B,EAAYuU,EAAI2gB,GAAA,EAAUxzB,EAAKV,EAAG2gB,EAAAtiB,EAAA,EAAAW,IAAkBgU,IAG5Eqc,EAGe,IAAA8E,GAAA,WACf,OAASnC,GAAeiC,IACxBjvB,MAAA,OACAitB,WAAA,SC/BO,SAAAmC,GAAAhe,EAAAC,GACP,OAAAD,EAAAC,GAGA+d,GAAAtY,OAAAsY,GAEe,IAAAC,GAAA,WACf,OAASjD,GAAUgD,IACnBpvB,MAAA,SCNO,SAAAsvB,GAAA3P,EAAAE,GACP,IAAAgF,EAAYvpB,EAAGqkB,GACf3lB,EAAA2lB,IAAAE,EAAsBvR,EAAGqR,IAAAkF,EAAcvpB,EAAGukB,OAAAF,GAC1C4P,EAAA1K,EAAA7qB,EAAA2lB,EAEA,GAAMjc,EAAG1J,GAAM8T,EAAO,OAASshB,GAE/B,SAAA/E,EAAA9uB,EAAAE,GACA,IAAA+zB,EAAAD,EAAA9zB,EAAAg0B,EAAAz1B,EAAAuB,EACA,OAAAi0B,EAAiBlhB,EAAGmhB,GAAAF,EAAAC,EAAel0B,EAAGm0B,IAQtC,OALApF,EAAAvT,OAAA,SAAAvb,EAAAE,GACA,IAAA+zB,EAAAD,EAAA9zB,EACA,OAAY4S,EAAK9S,EAAImI,EAAG8rB,IAAAx1B,EAAYuU,EAAIihB,GAAAD,EAAUhhB,EAAIvU,GAAM8I,EAAIvH,IAAAi0B,OAGhEnF,EAGe,IAAAqF,GAAA,WACf,OAAS1C,GAAesC,IACxBtvB,MAAA,SACA/D,QAAA,aCxBA0zB,GAAA,SACAC,IAAA,QACAC,GAAA,OACAC,GAAA,QACAC,GAAQjtB,EAAI,KAGL,SAAAktB,GAAA5e,EAAAC,GACP,IAAA7Y,EAAUkW,EAAIqhB,GAAKzhB,EAAG+C,IAAA4e,EAAAz3B,IAAA03B,EAAAD,MACtB,OACA7e,EAAa9V,EAAG9C,IAAAu3B,IAAAJ,GAAA,EAAAC,GAAAK,EAAAC,GAAA,EAAAL,GAAA,EAAAC,GAAAG,KAChBz3B,GAAAm3B,GAAAC,GAAAK,EAAAC,GAAAL,GAAAC,GAAAG,KAIAD,GAAAlZ,OAAA,SAAAvb,EAAAE,GAEA,IADA,IACAsY,EADAvb,EAAAiD,EAAAw0B,EAAAz3B,IAAA03B,EAAAD,MACA13B,EAAA,EAAiCA,EAZjC,KAeA23B,GAAAD,GAAAz3B,GAAAub,GAFAvb,GAAAm3B,GAAAC,GAAAK,EAAAC,GAAAL,GAAAC,GAAAG,IAAAx0B,IACAk0B,GAAA,EAAAC,GAAAK,EAAAC,GAAA,EAAAL,GAAA,EAAAC,GAAAG,KACAz3B,GAAAy3B,MACQvsB,EAAGqQ,G5DvBJ,U4DmB0Cxb,GAMjD,OACAw3B,GAAAx0B,GAAAo0B,GAAA,EAAAC,GAAAK,EAAAC,GAAA,EAAAL,GAAA,EAAAC,GAAAG,IAA+D30B,EAAG9C,GAC9DkW,EAAKJ,EAAG9V,GAAAu3B,MAIG,IAAAI,GAAA,WACf,OAAS/D,GAAU4D,IACnBhwB,MAAA,UC9BO,SAAAowB,GAAA70B,EAAAE,GACP,IAAAgb,EAAWnb,EAAGG,GAAAkW,EAASrW,EAAGC,GAAAkb,EAC1B,OAAAA,EAAenI,EAAG/S,GAAAoW,EAASrD,EAAG7S,GAAAkW,GAG9Bye,GAAAtZ,OAAqBsX,GAAgB1yB,GAEtB,IAAA20B,GAAA,WACf,OAASjE,GAAUgE,IACnBpwB,MAAA,SACA+sB,UAAA,KCTA,SAASuD,GAAcC,EAAAC,EAAAC,EAAAC,GACvB,WAAAH,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,EAAwDpL,GAAWiE,IACnE5c,MAAA,SAAApR,EAAAE,GACA6C,KAAA8O,OAAAT,MAAApR,EAAAg1B,EAAAE,EAAAh1B,EAAA+0B,EAAAE,MAKe,IAAAC,GAAA,WACf,IACAhR,EAAAC,EAAAC,EAEAiC,EACAC,EACAmH,EALAvX,EAAA,EAAA8e,EAAA,EAAAC,EAAA,EAAAE,EAAA,EAAAC,EAAA,EAAAnlB,EAAyD4Z,GACzD5F,EAAA,KACAkN,EAAiBtH,GAKjB,SAAA/X,IAEA,OADAuU,EAAAC,EAAA,KACAmH,EAGA,OAAAA,GACA9b,OAAA,SAAAA,GACA,OAAA0U,GAAAC,IAAA3U,EAAA0U,IAAApW,EAAAkhB,EAAA7K,EAAA3U,KAEAwf,SAAA,SAAA/T,GACA,OAAAle,UAAAC,QAAAgyB,EAAA/T,EAAA6G,EAAAC,EAAAC,EAAAC,EAAA,KAAAtS,KAAAqf,GAEAjD,WAAA,SAAA9Q,GACA,OAAAle,UAAAC,QAAAgyB,EAAA,MAAA/T,GAAA6G,EAAAC,EAAAC,EAAAC,EAAA,KAAmFyF,IAAYlF,GAAaV,GAAA7G,EAAA,MAAA8G,GAAA9G,EAAA,MAAA+G,GAAA/G,EAAA,MAAAgH,GAAAhH,EAAA,OAAAtL,KAAA,MAAAmS,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAE5G7f,MAAA,SAAA6Y,GACA,OAAAle,UAAAC,QAAA8Q,EAA6C4kB,IAAc3e,GAAAkH,GAAA+X,EAAAjf,EAAAkf,EAAAJ,EAAAC,GAAAnjB,KAAAoE,GAE3DiY,UAAA,SAAA/Q,GACA,OAAAle,UAAAC,QAAA8Q,EAA6C4kB,GAAc3e,EAAAif,EAAAjf,EAAAkf,EAAAJ,GAAA5X,EAAA,GAAA6X,GAAA7X,EAAA,IAAAtL,MAAAkjB,EAAAC,IAE3DI,SAAA,SAAAjY,GACA,OAAAle,UAAAC,QAAA8Q,EAA6C4kB,GAAc3e,GAAAif,EAAA/X,GAAA,KAAAlH,EAAAkf,EAAAJ,EAAAC,GAAAnjB,KAAAqjB,EAAA,GAE3DG,SAAA,SAAAlY,GACA,OAAAle,UAAAC,QAAA8Q,EAA6C4kB,GAAc3e,EAAAif,EAAAjf,GAAAkf,EAAAhY,GAAA,KAAA4X,EAAAC,GAAAnjB,KAAAsjB,EAAA,GAE3DhH,UAAA,SAAA7H,EAAA/nB,GACA,OAAa4vB,GAASX,EAAAlH,EAAA/nB,IAEtB8vB,QAAA,SAAAhgB,EAAA9P,GACA,OAAa8vB,GAAOb,EAAAnf,EAAA9P,IAEpB+vB,SAAA,SAAA5qB,EAAAnF,GACA,OAAa+vB,GAAQd,EAAA9pB,EAAAnF,IAErBgwB,UAAA,SAAA5qB,EAAApF,GACA,OAAagwB,GAASf,EAAA7pB,EAAApF,MCvDf,SAAA+2B,GAAA5f,EAAAC,GACP,IAAAqZ,EAAArZ,IAAA4f,EAAAvG,IACA,OACAtZ,GAAA,cAAAsZ,EAAAuG,MAAA,QAAAvG,EAAA,QAAAuG,GAAA,UACA5f,GAAA,SAAAqZ,GAAA,QAAAuG,GAAA,QAAAvG,EAAA,gBAAAuG,MAIAD,GAAAla,OAAA,SAAAvb,EAAAE,GACA,IAAAsY,EAAA1C,EAAA5V,EAAAlD,EAAA,GACA,GACA,IAAAmyB,EAAArZ,IAAA4f,EAAAvG,IACArZ,GAAA0C,GAAA1C,GAAA,SAAAqZ,GAAA,QAAAuG,GAAA,QAAAvG,EAAA,gBAAAuG,KAAAx1B,IACA,SAAAivB,GAAA,QAAAuG,GAAA,QAAAvG,EAAA,mBAAAuG,WACWvtB,EAAGqQ,GAAUjG,KAAOvV,EAAA,GAC/B,OACAgD,GAAA,OAAAmvB,EAAArZ,MAAAqZ,UAAA,gBAAAA,GAAA,mBACArZ,IAIe,IAAA6f,GAAA,WACf,OAAS9E,GAAU4E,IACnBhxB,MAAA,UCtBO,SAAAmxB,GAAA51B,EAAAE,GACP,OAAUH,EAAGG,GAAM6S,EAAG/S,GAAK+S,EAAG7S,IAG9B01B,GAAAra,OAAyBsX,GAAgB1f,GAE1B,IAAA0iB,GAAA,WACf,OAAShF,GAAU+E,IACnBnxB,MAAA,OACA+sB,UAAA,GAAsBjf,ICTf,SAAAujB,GAAA91B,EAAAE,GACP,IAAAgb,EAAWnb,EAAGG,GAAAkW,EAAA,EAAarW,EAAGC,GAAAkb,EAC9B,OAAAA,EAAenI,EAAG/S,GAAAoW,EAASrD,EAAG7S,GAAAkW,GAG9B0f,GAAAva,OAA0BsX,GAAe,SAAA5yB,GACzC,SAAaE,EAAIF,KAGF,IAAA81B,GAAA,WACf,OAASlF,GAAUiF,IACnBrxB,MAAA,KACA+sB,UAAA,MCbO,SAAAwE,GAAAngB,EAAAC,GACP,OAAUlW,EAAIC,GAAK4S,EAAMqD,GAAA,KAAAD,GAGzBmgB,GAAAza,OAAA,SAAAvb,EAAAE,GACA,QAAAA,EAAA,EAAkBC,EAAKC,EAAGJ,IAAOyS,IAGlB,IAAAwjB,GAAA,WACf,IAAA74B,EAAUm2B,GAAkByC,IAC5Bt1B,EAAAtD,EAAAsD,OACA4b,EAAAlf,EAAAkf,OAUA,OARAlf,EAAAsD,OAAA,SAAA4c,GACA,OAAAle,UAAAC,OAAAqB,IAAA4c,EAAA,GAAAA,EAAA,OAAAA,EAAA5c,KAAA,IAAA4c,EAAA,KAGAlgB,EAAAkf,OAAA,SAAAgB,GACA,OAAAle,UAAAC,OAAAid,GAAAgB,EAAA,GAAAA,EAAA,GAAAA,EAAAje,OAAA,EAAAie,EAAA,aAAAA,EAAAhB,KAAA,GAAAgB,EAAA,GAAAA,EAAA,QAGAhB,GAAA,SACA7X,MAAA,UCzBA3H,EAAAQ,EAAA44B,EAAA,4BAAA3f,IAAAzZ,EAAAQ,EAAA44B,EAAA,8BAAAvrB,KAAA7N,EAAAQ,EAAA44B,EAAA,gCAAA9a,KAAAte,EAAAQ,EAAA44B,EAAA,8BAAAjZ,KAAAngB,EAAAQ,EAAA44B,EAAA,wCAAAjU,KAAAnlB,EAAAQ,EAAA44B,EAAA,kCAAA1T,KAAA1lB,EAAAQ,EAAA44B,EAAA,kCAAA5P,KAAAxpB,EAAAQ,EAAA44B,EAAA,qCAAArR,KAAA/nB,EAAAQ,EAAA44B,EAAA,gCAAArO,KAAA/qB,EAAAQ,EAAA44B,EAAA,gCAAA/O,KAAArqB,EAAAQ,EAAA44B,EAAA,iCAAAlO,KAAAlrB,EAAAQ,EAAA44B,EAAA,mCAAAlN,KAAAlsB,EAAAQ,EAAA44B,EAAA,mCAAA7M,KAAAvsB,EAAAQ,EAAA44B,EAAA,8BAAAlP,KAAAlqB,EAAAQ,EAAA44B,EAAA,4BAAAxI,KAAA5wB,EAAAQ,EAAA44B,EAAA,8BAAAlE,KAAAl1B,EAAAQ,EAAA44B,EAAA,iCAAAjE,KAAAn1B,EAAAQ,EAAA44B,EAAA,0CAAAhD,KAAAp2B,EAAAQ,EAAA44B,EAAA,6CAAAlD,KAAAl2B,EAAAQ,EAAA44B,EAAA,4CAAA9C,KAAAt2B,EAAAQ,EAAA44B,EAAA,+CAAA/C,KAAAr2B,EAAAQ,EAAA44B,EAAA,sCAAAtC,KAAA92B,EAAAQ,EAAA44B,EAAA,yCAAAxC,KAAA52B,EAAAQ,EAAA44B,EAAA,sCAAAnE,KAAAj1B,EAAAQ,EAAA44B,EAAA,yCAAAvE,KAAA70B,EAAAQ,EAAA44B,EAAA,wCAAA/B,KAAAr3B,EAAAQ,EAAA44B,EAAA,2CAAAnC,KAAAj3B,EAAAQ,EAAA44B,EAAA,kCAAAtB,KAAA93B,EAAAQ,EAAA44B,EAAA,qCAAAzB,KAAA33B,EAAAQ,EAAA44B,EAAA,uCAAApC,KAAAh3B,EAAAQ,EAAA44B,EAAA,0CAAArC,KAAA/2B,EAAAQ,EAAA44B,EAAA,gCAAApB,KAAAh4B,EAAAQ,EAAA44B,EAAA,mCAAArB,KAAA/3B,EAAAQ,EAAA44B,EAAA,gCAAAd,KAAAt4B,EAAAQ,EAAA44B,EAAA,kCAAArF,KAAA/zB,EAAAQ,EAAA44B,EAAA,yCAAApF,KAAAh0B,EAAAQ,EAAA44B,EAAA,gCAAA5C,KAAAx2B,EAAAQ,EAAA44B,EAAA,mCAAA7C,KAAAv2B,EAAAQ,EAAA44B,EAAA,qCAAAP,KAAA74B,EAAAQ,EAAA44B,EAAA,wCAAAT,KAAA34B,EAAAQ,EAAA44B,EAAA,oCAAAL,KAAA/4B,EAAAQ,EAAA44B,EAAA,uCAAAN,KAAA94B,EAAAQ,EAAA44B,EAAA,qCAAAH,KAAAj5B,EAAAQ,EAAA44B,EAAA,wCAAAJ,KAAAh5B,EAAAQ,EAAA44B,EAAA,0CAAAD,KAAAn5B,EAAAQ,EAAA44B,EAAA,6CAAAF,KAAAl5B,EAAAQ,EAAA44B,EAAA,gCAAA7Z,KAAAvf,EAAAQ,EAAA44B,EAAA,8BAAA9gB,IAAAtY,EAAAQ,EAAA44B,EAAA,iCAAApI,0CCAe,IAAAqI,EAAA,SAAAn2B,GACf,OAAAA,GCCe8tB,EAAA,SAAA3d,GACf,SAAAA,EAAA,OAAgCgmB,EAChC,IAAAhS,EACAC,EACA4Q,EAAA7kB,EAAA1L,MAAA,GACAwwB,EAAA9kB,EAAA1L,MAAA,GACAggB,EAAAtU,EAAAke,UAAA,GACA3J,EAAAvU,EAAAke,UAAA,GACA,gBAAA+H,EAAAp5B,GACAA,IAAAmnB,EAAAC,EAAA,GACA,IAAA3E,EAAA,EAAAhhB,EAAA23B,EAAA/2B,OAAAg3B,EAAA,IAAAlxB,MAAA1G,GAGA,IAFA43B,EAAA,IAAAlS,GAAAiS,EAAA,IAAApB,EAAAvQ,EACA4R,EAAA,IAAAjS,GAAAgS,EAAA,IAAAnB,EAAAvQ,EACAjF,EAAAhhB,GAAA43B,EAAA5W,GAAA2W,EAAA3W,OACA,OAAA4W,ICdeC,EAAA,SAAAC,GACf,IAAmBh4B,EAAnBL,EAAU4vB,EAASyI,EAAApmB,WACnBgU,EAAAhK,IAAAiK,EAAAD,EAAAE,GAAAF,EAAAG,GAAAH,EAEA,SAAAqS,EAAA13B,IACAA,EAAAZ,EAAAY,IACA,GAAAqlB,MAAArlB,EAAA,IACAA,EAAA,GAAAulB,MAAAvlB,EAAA,IACAA,EAAA,GAAAslB,MAAAtlB,EAAA,IACAA,EAAA,GAAAwlB,MAAAxlB,EAAA,IAGA,SAAA23B,EAAAh5B,GACA,OAAAA,EAAAsE,MACA,yBAAAtE,EAAA+W,WAAAhL,QAAAitB,GAAoE,MACpE,YAAAD,EAAA/4B,EAAAuW,aAA6C,MAC7C,iBAAAvW,EAAAuW,YAAAxK,QAAAgtB,IAeA,IAAAj4B,KAXAg4B,EAAAG,KAAAltB,QAAA,SAAA+E,GAEA,IADA,IAAAzP,EAAA9B,GAAA,EAAAyB,EAAA8P,EAAAlP,SACArC,EAAAyB,IACAK,EAAAZ,EAAAqQ,EAAAvR,OACA,GAAAmnB,MAAArlB,EAAA,IACAA,EAAA,GAAAulB,MAAAvlB,EAAA,IACAA,EAAA,GAAAslB,MAAAtlB,EAAA,IACAA,EAAA,GAAAwlB,MAAAxlB,EAAA,MAIAy3B,EAAAI,QACAF,EAAAF,EAAAI,QAAAp4B,IAGA,OAAA4lB,EAAAC,EAAAC,EAAAC,ICrCeqE,EAAA,SAAA3J,EAAAvgB,GAEf,IADA,IAAAP,EAAAuhB,EAAAT,EAAA3f,OAAArC,EAAAyiB,EAAAhhB,EACAzB,IAAAyiB,GAAAvhB,EAAA8gB,EAAAhiB,GAAAgiB,EAAAhiB,KAAAgiB,EAAAS,GAAAT,EAAAS,GAAAvhB,GCCA8b,EAAA,SAAeuc,EAAA94B,GACf,6BAAAA,EAAAsE,MACSA,KAAA,oBAAA6R,SAAAnW,EAAA+W,WAAAnP,IAAA,SAAA5H,GAAmE,OAAQm5B,EAAOL,EAAA94B,MACnFm5B,EAAOL,EAAA94B,IAGR,SAASm5B,EAAOL,EAAA94B,GACvB,IAAA8P,EAAA9P,EAAA8P,GACA+oB,EAAA74B,EAAA64B,KACAO,EAAA,MAAAp5B,EAAAo5B,cAA4Cp5B,EAAAo5B,WAC5CtjB,EAAiBujB,EAAMP,EAAA94B,GACvB,aAAA8P,GAAA,MAAA+oB,GAAuCv0B,KAAA,UAAA80B,aAAAtjB,YACvC,MAAA+iB,GAAwBv0B,KAAA,UAAAwL,KAAAspB,aAAAtjB,aACfxR,KAAA,UAAAwL,KAAA+oB,OAAAO,aAAAtjB,YAGF,SAASujB,EAAMP,EAAA94B,GACtB,IAAAs5B,EAAuBjJ,EAASyI,EAAApmB,WAChCumB,EAAAH,EAAAG,KAEA,SAAAnoB,EAAAvR,EAAA+gB,GACAA,EAAA1e,QAAA0e,EAAAJ,MACA,QAAAvU,EAAAstB,EAAA15B,EAAA,GAAAA,KAAAoZ,EAAA,EAAA3X,EAAA2K,EAAA/J,OAA2D+W,EAAA3X,IAAO2X,EAClE2H,EAAA/Y,KAAA+xB,EAAA3tB,EAAAgN,OAEApZ,EAAA,GAAe2rB,EAAO5K,EAAAtf,GAGtB,SAAA2S,EAAAtS,GACA,OAAAi4B,EAAAj4B,GAGA,SAAA0e,EAAAkZ,GAEA,IADA,IAAA3Y,KACA/gB,EAAA,EAAAyB,EAAAi4B,EAAAr3B,OAAoCrC,EAAAyB,IAAOzB,EAAAuR,EAAAmoB,EAAA15B,GAAA+gB,GAE3C,OADAA,EAAA1e,OAAA,GAAA0e,EAAA/Y,KAAA+Y,EAAA,IACAA,EAGA,SAAAb,EAAAwZ,GAEA,IADA,IAAA3Y,EAAAP,EAAAkZ,GACA3Y,EAAA1e,OAAA,GAAA0e,EAAA/Y,KAAA+Y,EAAA,IACA,OAAAA,EAGA,SAAA3S,EAAAsrB,GACA,OAAAA,EAAArxB,IAAA6X,GAkBA,OAfA,SAAA3J,EAAA9V,GACA,IAAAuW,EAAAjS,EAAAtE,EAAAsE,KACA,OAAAA,GACA,gCAAyCA,OAAAyS,WAAA/W,EAAA+W,WAAAnP,IAAAkO,IACzC,YAAAS,EAAA5C,EAAA3T,EAAAuW,aAAuD,MACvD,iBAAAA,EAAAvW,EAAAuW,YAAA3O,IAAA+L,GAAgE,MAChE,iBAAA4C,EAAAwJ,EAAA/f,EAAAi5B,MAAoD,MACpD,sBAAA1iB,EAAAvW,EAAAi5B,KAAArxB,IAAAmY,GAA6D,MAC7D,cAAAxJ,EAAA5I,EAAA3N,EAAAi5B,MAAoD,MACpD,mBAAA1iB,EAAAvW,EAAAi5B,KAAArxB,IAAA+F,GAA6D,MAC7D,oBAEA,OAAYrJ,OAAAiS,eAGZT,CAAA9V,GCnEe,IAAAu5B,EAAA,SAAAT,EAAAG,GACf,IAAAO,KACAC,KACAC,KACAC,KACAC,GAAA,EAmDA,SAAAC,EAAAH,EAAAD,GACA,QAAA9gB,KAAA+gB,EAAA,CACA,IAAA/W,EAAA+W,EAAA/gB,UACA8gB,EAAA9W,EAAAvB,cACAuB,EAAAvB,aACAuB,EAAAmX,IACAnX,EAAA5W,QAAA,SAAAxM,GAA6Bi6B,EAAAj6B,EAAA,GAAAA,KAAA,IAC7Bo6B,EAAApyB,KAAAob,IAQA,OA/DAsW,EAAAltB,QAAA,SAAAxM,EAAAyiB,GACA,IAAAvhB,EAAAqQ,EAAAgoB,EAAAG,KAAA15B,EAAA,GAAAA,KACAuR,EAAAlP,OAAA,IAAAkP,EAAA,QAAAA,EAAA,QACArQ,EAAAw4B,IAAAW,GAAAX,EAAAW,GAAAr6B,EAAA05B,EAAAjX,GAAAvhB,KAIAw4B,EAAAltB,QAAA,SAAAxM,GACA,IAGAojB,EAAA4T,EAHA9V,EAiCA,SAAAlhB,GACA,IAAA2hB,EAAApQ,EAAAgoB,EAAAG,KAAA15B,EAAA,GAAAA,KAAA0hB,EAAAnQ,EAAA,GACAgoB,EAAApmB,WAAAwO,GAAA,KAAApQ,EAAA/E,QAAA,SAAAguB,GAAmE7Y,EAAA,IAAA6Y,EAAA,GAAA7Y,EAAA,IAAA6Y,EAAA,MACnE7Y,EAAApQ,IAAAlP,OAAA,GACA,OAAArC,EAAA,GAAA2hB,EAAAD,MAAAC,GArCA8Y,CAAAz6B,GACA6hB,EAAAX,EAAA,GACAqZ,EAAArZ,EAAA,GAGA,GAAAkC,EAAA+W,EAAAtY,GAIA,UAHAsY,EAAA/W,EAAAmX,KACAnX,EAAApb,KAAAhI,GACAojB,EAAAmX,MACAvD,EAAAkD,EAAAK,GAAA,QACAL,EAAAlD,EAAAnV,OACA,IAAA6Y,EAAA1D,IAAA5T,MAAAhf,OAAA4yB,GACAkD,EAAAQ,EAAA7Y,MAAAuB,EAAAvB,OAAAsY,EAAAO,EAAAH,IAAAvD,EAAAuD,KAAAG,OAEAR,EAAA9W,EAAAvB,OAAAsY,EAAA/W,EAAAmX,KAAAnX,OAEK,GAAAA,EAAA8W,EAAAK,GAIL,UAHAL,EAAA9W,EAAAvB,OACAuB,EAAAuX,QAAA36B,GACAojB,EAAAvB,QACAmV,EAAAmD,EAAAtY,GAAA,QACAsY,EAAAnD,EAAAuD,KACA,IAAAK,EAAA5D,IAAA5T,IAAA4T,EAAA5yB,OAAAgf,GACA8W,EAAAU,EAAA/Y,MAAAmV,EAAAnV,OAAAsY,EAAAS,EAAAL,IAAAnX,EAAAmX,KAAAK,OAEAV,EAAA9W,EAAAvB,OAAAsY,EAAA/W,EAAAmX,KAAAnX,OAIA8W,GADA9W,GAAApjB,IACA6hB,SAAAsY,EAAA/W,EAAAmX,OAAAnX,IAsBAkX,EAAAH,EAAAD,GACAI,EAAAJ,EAAAC,GACAT,EAAAltB,QAAA,SAAAxM,GAA4Bi6B,EAAAj6B,EAAA,GAAAA,MAAAo6B,EAAApyB,MAAAhI,MAE5Bo6B,GCpEA5lB,EAAA,SAAe+kB,GACf,OAASO,EAAMP,EAAAsB,EAAAxa,MAAAta,KAAA3D,aAGR,SAAAy4B,EAAAtB,EAAA73B,EAAAgI,GACP,IAAAgwB,EAAA15B,EAAAyB,EACA,GAAAW,UAAAC,OAAA,EAAAq3B,EAKA,SAAAH,EAAA73B,EAAAgI,GACA,IAEAoxB,EAFApB,KACAqB,KAGA,SAAAC,EAAAh7B,GACA,IAAAyiB,EAAAziB,EAAA,GAAAA,KACA+6B,EAAAtY,KAAAsY,EAAAtY,QAAAza,MAAkDhI,IAAAg3B,EAAA8D,IAGlD,SAAAG,EAAAvB,GACAA,EAAAltB,QAAAwuB,GAGA,SAAAE,EAAAxB,GACAA,EAAAltB,QAAAyuB,GAsBA,OAfA,SAAA1kB,EAAA9V,GACA,OAAAq6B,EAAAr6B,IAAAsE,MACA,yBAAAtE,EAAA+W,WAAAhL,QAAA+J,GAAgE,MAChE,iBAAA0kB,EAAAx6B,EAAAi5B,MAA0C,MAC1C,oCAAAwB,EAAAz6B,EAAAi5B,MAA+D,MAC/D,oBATA,SAAAA,GACAA,EAAAltB,QAAA0uB,GAQAC,CAAA16B,EAAAi5B,OAIAnjB,CAAA7U,GAEAq5B,EAAAvuB,QAAA,MAAA9C,EACA,SAAA0xB,GAAyB1B,EAAA1xB,KAAAozB,EAAA,GAAAp7B,IACzB,SAAAo7B,GAAyB1xB,EAAA0xB,EAAA,GAAApE,EAAAoE,IAAA/4B,OAAA,GAAA20B,IAAA0C,EAAA1xB,KAAAozB,EAAA,GAAAp7B,KAEzB05B,EA1CA2B,CAAA9B,EAAA73B,EAAAgI,QACA,IAAA1J,EAAA,EAAA05B,EAAA,IAAAvxB,MAAA1G,EAAA83B,EAAAG,KAAAr3B,QAA8DrC,EAAAyB,IAAOzB,EAAA05B,EAAA15B,KACrE,OAAU+E,KAAA,kBAAA20B,KAA+BM,EAAMT,EAAAG,ICF/C,IAAA1V,EAAA,SAAeuV,GACf,OAASO,EAAMP,EAAA+B,EAAAjb,MAAAta,KAAA3D,aAGR,SAAAk5B,EAAA/B,EAAAI,GACP,IAAA4B,KACA1zB,KACA2zB,KAYA,SAAAC,EAAArtB,GACAA,EAAA5B,QAAA,SAAA0T,GACAA,EAAA1T,QAAA,SAAA+E,IACAgqB,EAAAhqB,IAAA,GAAAA,OAAAgqB,EAAAhqB,QAAAvJ,KAAAoG,OAGAvG,EAAAG,KAAAoG,GAGA,SAAAif,EAAAnN,GACA,OAnCA,SAAAA,GAEA,IADA,IAAA9T,EAAApM,GAAA,EAAAyB,EAAAye,EAAA7d,OAAAgK,EAAA6T,EAAAze,EAAA,GAAA4rB,EAAA,IACArtB,EAAAyB,GAAA2K,EAAAC,IAAA6T,EAAAlgB,GAAAqtB,GAAAjhB,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACA,OAAA7J,KAAA2I,IAAAkiB,GAgCAqO,CAA0B5B,EAAMP,GAAYx0B,KAAA,UAAA20B,MAAAxZ,KAA8BlJ,YAAA,IA6B1E,OAjDA2iB,EAAAntB,QAEA,SAAA+J,EAAA9V,GACA,OAAAA,EAAAsE,MACA,yBAAAtE,EAAA+W,WAAAhL,QAAA+J,GAAgE,MAChE,cAAAklB,EAAAh7B,EAAAi5B,MAAsC,MACtC,mBAAAj5B,EAAAi5B,KAAAltB,QAAAivB,MAiBA5zB,EAAA2E,QAAA,SAAA4B,GACA,IAAAA,EAAAkS,EAAA,CACA,IAAAqb,KACAC,GAAAxtB,GAGA,IAFAA,EAAAkS,EAAA,EACAkb,EAAAxzB,KAAA2zB,GACAvtB,EAAAwtB,EAAAjb,OACAgb,EAAA3zB,KAAAoG,GACAA,EAAA5B,QAAA,SAAA0T,GACAA,EAAA1T,QAAA,SAAA+E,GACAgqB,EAAAhqB,EAAA,GAAAA,KAAA/E,QAAA,SAAA4B,GACAA,EAAAkS,IACAlS,EAAAkS,EAAA,EACAsb,EAAA5zB,KAAAoG,aASAvG,EAAA2E,QAAA,SAAA4B,UACAA,EAAAkS,KAIAvb,KAAA,eACA20B,KAAA8B,EAAAnzB,IAAA,SAAAR,GACA,IAAApG,EAAAi4B,KAmBA,GAhBA7xB,EAAA2E,QAAA,SAAA4B,GACAA,EAAA5B,QAAA,SAAA0T,GACAA,EAAA1T,QAAA,SAAA+E,GACAgqB,EAAAhqB,EAAA,GAAAA,KAAAlP,OAAA,GACAq3B,EAAA1xB,KAAAuJ,UAYA9P,GALAi4B,EAAaM,EAAMT,EAAAG,IAKnBr3B,QAAA,EACA,QAAAw5B,EAAA36B,EAAAlB,EAAA,EAAAoZ,EAAAiU,EAAAqM,EAAA,IAAiD15B,EAAAyB,IAAOzB,GACxD67B,EAAAxO,EAAAqM,EAAA15B,KAAAoZ,IACAlY,EAAAw4B,EAAA,GAAAA,EAAA,GAAAA,EAAA15B,GAAA05B,EAAA15B,GAAAkB,EAAAkY,EAAAyiB,GAKA,OAAAnC,KCjGe,IAAAoC,EAAA,SAAA1vB,EAAApJ,GAEf,IADA,IAAAugB,EAAA,EAAAC,EAAApX,EAAA/J,OACAkhB,EAAAC,GAAA,CACA,IAAAC,EAAAF,EAAAC,IAAA,EACApX,EAAAqX,GAAAzgB,EAAAugB,EAAAE,EAAA,EACAD,EAAAC,EAEA,OAAAF,GCLewY,EAAA,SAAApC,GACf,IAAAqC,KACAJ,EAAAjC,EAAAtxB,IAAA,WAA0C,WAE1C,SAAAmY,EAAAkZ,EAAA15B,GACA05B,EAAAltB,QAAA,SAAAJ,GACAA,EAAA,IAAAA,MACA,IAAA3L,EAAAu7B,EAAA5vB,GACA3L,IAAAuH,KAAAhI,GACAg8B,EAAA5vB,IAAApM,KAIA,SAAAoO,EAAAsrB,EAAA15B,GACA05B,EAAAltB,QAAA,SAAA+E,GAAgCiP,EAAAjP,EAAAvR,KAQhC,IAAAi8B,GACA/kB,WAAAsJ,EACApJ,gBAAAhJ,EACA7I,QAAA6I,EACAkJ,aAAA,SAAAoiB,EAAA15B,GAAqC05B,EAAAltB,QAAA,SAAA+E,GAA6BnD,EAAAmD,EAAAvR,OAKlE,QAAAA,KAFA25B,EAAAntB,QAZA,SAAA+J,EAAA9V,EAAAT,GACA,uBAAAS,EAAAsE,KAAAtE,EAAA+W,WAAAhL,QAAA,SAAA/L,GAA2E8V,EAAA9V,EAAAT,KAC3ES,EAAAsE,QAAAk3B,KAAAx7B,EAAAsE,MAAAtE,EAAAi5B,KAAA15B,KAYAg8B,EACA,QAAAE,EAAAF,EAAAh8B,GAAAI,EAAA87B,EAAA75B,OAAAogB,EAAA,EAAkEA,EAAAriB,IAAOqiB,EACzE,QAAArJ,EAAAqJ,EAAA,EAAyBrJ,EAAAhZ,IAAOgZ,EAAA,CAChC,IAAA3X,EAAA06B,EAAAD,EAAAzZ,GAAA2Z,EAAAF,EAAA9iB,IACA3X,EAAAm6B,EAAAO,IAAAn8B,EAAoC87B,EAAMr6B,EAAA26B,SAAA36B,EAAA8K,OAAAvM,EAAA,EAAAo8B,IAC1C36B,EAAAm6B,EAAAQ,IAAAp8B,EAAoC87B,EAAMr6B,EAAA06B,SAAA16B,EAAA8K,OAAAvM,EAAA,EAAAm8B,GAK1C,OAAAP,GCzCeS,EAAA,SAAAlpB,GACf,SAAAA,EAAA,OAAgCgmB,EAChC,IAAAhS,EACAC,EACA4Q,EAAA7kB,EAAA1L,MAAA,GACAwwB,EAAA9kB,EAAA1L,MAAA,GACAggB,EAAAtU,EAAAke,UAAA,GACA3J,EAAAvU,EAAAke,UAAA,GACA,gBAAA+H,EAAAp5B,GACAA,IAAAmnB,EAAAC,EAAA,GACA,IAAA3E,EAAA,EACAhhB,EAAA23B,EAAA/2B,OACAg3B,EAAA,IAAAlxB,MAAA1G,GACA4lB,EAAA7kB,KAAA8H,OAAA8uB,EAAA,GAAA3R,GAAAuQ,GACA1Q,EAAA9kB,KAAA8H,OAAA8uB,EAAA,GAAA1R,GAAAuQ,GAGA,IAFAoB,EAAA,GAAAhS,EAAAF,IAAAE,EACAgS,EAAA,GAAA/R,EAAAF,IAAAE,EACA7E,EAAAhhB,GAAA43B,EAAA5W,GAAA2W,EAAA3W,OACA,OAAA4W,ICjBeiD,EAAA,SAAA/C,EAAApmB,GACf,GAAAomB,EAAApmB,UAAA,UAAAlN,MAAA,qBAEA,GAAAkN,KAAA1L,MAMA80B,EAAAhD,EAAAD,SANA,CACA,MAAA73B,EAAAe,KAAAE,MAAAyQ,KAAA,aAAAlN,MAAA,gBAEA,IAAAxE,EAAA0lB,GADAoV,EAAAhD,EAAAD,MAA2BA,EAAIC,IAC/B,GAAAnS,EAAAmV,EAAA,GAAAlV,EAAAkV,EAAA,GAAAjV,EAAAiV,EAAA,GACAppB,GAAiB1L,OAAA4f,EAAAF,GAAAE,EAAAF,IAAA1lB,EAAA,KAAA6lB,EAAAF,GAAAE,EAAAF,IAAA3lB,EAAA,MAAA4vB,WAAAlK,EAAAC,IAKjB,IAAqBmV,EAAAh7B,EAArBL,EAAUm7B,EAAWlpB,GAAAqpB,EAAAjD,EAAAI,QAAA8C,KAErB,SAAAC,EAAAtoB,GACA,OAAAlT,EAAAkT,GAGA,SAAAuoB,EAAAvD,GACA,IAAAC,EACA,OAAAD,EAAAr0B,MACA,yBAAAs0B,GAA2Ct0B,KAAA,qBAAAyS,WAAA4hB,EAAA5hB,WAAAnP,IAAAs0B,IAAgF,MAC3H,YAAAtD,GAA8Bt0B,KAAA,QAAAiS,YAAA0lB,EAAAtD,EAAApiB,cAA8D,MAC5F,iBAAAqiB,GAAmCt0B,KAAA,aAAAiS,YAAAoiB,EAAApiB,YAAA3O,IAAAq0B,IAAuE,MAC1G,eAAAtD,EAKA,OAHA,MAAAA,EAAA7oB,KAAA8oB,EAAA9oB,GAAA6oB,EAAA7oB,IACA,MAAA6oB,EAAAE,OAAAD,EAAAC,KAAAF,EAAAE,MACA,MAAAF,EAAAS,aAAAR,EAAAQ,WAAAT,EAAAS,YACAR,EAYA,IAAA93B,KAAAi7B,EAAAC,EAAAl7B,GAAAo7B,EAAAH,EAAAj7B,IAEA,OACAwD,KAAA,WACAu0B,KAAAiD,EACAppB,YACAwmB,QAAA8C,EACA/C,KAAAH,EAAAG,KAAArxB,IAhBA,SAAA+wB,GACA,IAAAt3B,EAAA9B,EAAA,EAAAyiB,EAAA,EAAAhhB,EAAA23B,EAAA/2B,OAAAg3B,EAAA,IAAAlxB,MAAA1G,GAEA,IADA43B,EAAA,GAAAn4B,EAAAk4B,EAAA,QACAp5B,EAAAyB,KAAAK,EAAAZ,EAAAk4B,EAAAp5B,OAAA,IAAA8B,EAAA,MAAAu3B,EAAA5W,KAAA3gB,GAGA,OAFA,IAAA2gB,IAAA4W,EAAA5W,MAAA,MACA4W,EAAAh3B,OAAAogB,EACA4W,MCzCAv5B,EAAAQ,EAAA44B,EAAA,yBAAAI,IAAAx5B,EAAAQ,EAAA44B,EAAA,4BAAAlc,IAAAld,EAAAQ,EAAA44B,EAAA,yBAAA1kB,IAAA1U,EAAAQ,EAAA44B,EAAA,6BAAA2B,IAAA/6B,EAAAQ,EAAA44B,EAAA,0BAAAlV,IAAAlkB,EAAAQ,EAAA44B,EAAA,8BAAAoC,IAAAx7B,EAAAQ,EAAA44B,EAAA,8BAAA6C,IAAAj8B,EAAAQ,EAAA44B,EAAA,6BAAAoD,IAAAx8B,EAAAQ,EAAA44B,EAAA,8BAAApI,IAAAhxB,EAAAQ,EAAA44B,EAAA,gCAAAmD","file":"LightningMaps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"LightningMaps\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"LightningMaps\"] = factory();\n\telse\n\t\troot[\"LightningMaps\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// Based on https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#ECMAScript_.28JavaScript.2FActionScript.2C_etc..29\nexport default class TileConversion {\n  static lon2tile(lon, zoom, rounded = true) {\n    const tile = (lon + 180) / 360 * Math.pow(2, zoom);\n\n    return rounded\n      ? Math.floor(tile)\n      : tile;\n  }\n\n  static lat2tile(lat, zoom, rounded = true) {\n    const tile = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180))\n      / Math.PI) / 2 * Math.pow(2, zoom);\n\n    return rounded\n      ? Math.floor(tile)\n      : tile;\n  }\n\n  static tile2lon(x, z) {\n    return x / Math.pow(2, z) * 360 - 180;\n  }\n\n  static tile2lat(y, z) {\n    const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);\n\n    return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  }\n\n  static tile2boundingBox(x, y, zoom) {\n    return {\n      ne: [\n        TileConversion.tile2lat(y, zoom),\n        TileConversion.tile2lon(x + 1, zoom)\n      ],\n\n      sw: [\n        TileConversion.tile2lat(y + 1, zoom),\n        TileConversion.tile2lon(x, zoom)\n      ]\n    };\n  }\n\n  static pixelToLatLon(pixel, center, zoom, tileSize) {\n    const pointDiff = [\n      pixel[0] / tileSize,\n      pixel[1] / tileSize\n    ];\n\n    const tileX = TileConversion.lon2tile(center[1], zoom, false) - pointDiff[0];\n    const tileY = TileConversion.lat2tile(center[0], zoom, false) - pointDiff[1];\n\n    return [\n      TileConversion.tile2lat(tileY, zoom),\n      TileConversion.tile2lon(tileX, zoom)\n    ];\n  }\n\n  static latLonToPixel(coord, center, zoom, tileSize, mapDimensions) {\n    const tileX = TileConversion.lon2tile(coord[1], zoom, false);\n    const tileY = TileConversion.lat2tile(coord[0], zoom, false);\n\n    const tileCenterX = TileConversion.lon2tile(center[1], zoom, false);\n    const tileCenterY = TileConversion.lat2tile(center[0], zoom, false);\n\n    return [\n      -(tileX - tileCenterX) * tileSize,\n      -(tileY - tileCenterY) * tileSize\n    ];\n  }\n}\n","export const defaultMapOptions = {\n  /**\n   * Common options\n   */\n  source: (x, y, z) => `https://maps.geocod.io/tiles/base/${z}/${x}/${y}.png`,\n  zoom: 12,\n  center: [38.841779, -77.088312],\n  attribution: ' OpenStreetMap contributors',\n\n  /**\n   * Width and height in pixels for each tile, you most likely do not want to change this.\n   */\n  tileSize: 256,\n\n  /**\n   * Determines the distance travelled when panning the map, the higher the value the further the\n   * distance\n   */\n  panAccelerationMultiplier: 2,\n\n  /**\n   * The maximum acceleration constant for when the map is thrown. This is in place to avoid\n   * super-sonic acceleration speeds :)\n   */\n  maxPanAcceleration: 3.5,\n\n  /**\n   * Only consider high velocity mouse movements that has been performed within this timing\n   * threshold (in milliseconds)\n   */\n  throwTimingThresholdMs: 100,\n\n  /**\n   * If the mouse panning velocity is above this threshold, it is considering a throw rather than\n   * a regular pan. We use this to pan further when the mouse is moved quickly\n   */\n  throwVelocityThreshold: 3000,\n\n  /**\n   * How quickly panning and zooming animations are executed (in milliseconds)\n   */\n  animationDurationMs: 300,\n\n  /*\n   * Used for debouncing events such as scrolling\n   */\n  debounceIntervalMs: 200,\n\n  /**\n   * Determines how many additional tiles that should be loaded, to decrease map load times when\n   * panning the map around\n\n   * Minimum value: 1.25\n   */\n  tileAreaMultiplier: 2,\n\n  /**\n   * When debug mode is enabled, additional rendering artifacts are drawn. Should only be used in\n   * conjuction with development of the library\n   */\n  debug: false\n};\n\nexport const defaultMarkerOptions = {\n  /**\n   * What color should the marker be?\n   * Supports hex, rgb and rgba values\n   */\n  color: 'rgba(0, 0, 200, 0.7)',\n\n  /**\n   * Valid values: marker, circle, donut\n   */\n  type: 'marker'\n};\n\nexport const defaultPolygonOptions = {\n  /**\n   * What color should the polygon be?\n   * Supports hex, rgb and rgba values\n   */\n  color: 'rgba(0, 0, 200, 0.7)'\n};\n","import Map from './Map';\nimport Marker from './Marker';\nimport Polygon from './Polygon';\n\nexport default {\n  Map,\n  Marker,\n  Polygon\n};\n","import TileConversion from './TileConversion';\nimport TileLayer from './TileLayer';\nimport MapState from './MapState';\nimport { defaultMapOptions } from './defaultOptions';\n\nexport default class Map {\n\n  constructor(canvas, options) {\n    if (!canvas || !canvas.getContext) {\n      throw new Error('Could not get canvas context');\n    }\n\n    this.canvas = canvas;\n    this.context = this.canvas.getContext('2d');\n\n    this.options = Object.assign({}, defaultMapOptions, options);\n\n    this.initializeState();\n    this.attachEvents();\n    this.applyStyles();\n\n    this.lastDrawState = null;\n\n    this.draw = this.draw.bind(this);\n    window.requestAnimationFrame(this.draw);\n  }\n\n  initializeState() {\n    this.state = {\n      canvasDimensions: [this.canvas.width, this.canvas.height],\n      tiles: {},\n      moveOffset: [0, 0],\n      targetMoveOffset: [0, 0],\n      targetMoveOffsetIsCoord: false,\n      moveAnimationStart: null,\n      dragStartPosition: null,\n      lastEventActionTime: null,\n      startZoom: this.options.zoom,\n      targetZoom: this.options.zoom,\n      zoomAnimationStart: null,\n      scale: 1,\n      lastMouseMoveEvent: null,\n      mouseVelocities: [],\n      markers: [],\n      polygons: [],\n      tileLayers: [\n        new TileLayer(this)\n      ]\n    };\n  }\n\n  getZoom() {\n    return this.options.zoom;\n  }\n\n  setZoom(zoom) {\n    if (this.zoomValueIsValid(zoom)) {\n      this.state.tileLayers.push(new TileLayer(this, zoom));\n      // this.state.tileLayers[0].tilesZoomLevel = this.options.zoom;\n\n      this.state.lastEventActionTime = window.performance.now();\n      this.state.zoomAnimationStart = window.performance.now();\n      this.state.targetZoom = zoom;\n      this.state.startZoom = this.options.zoom;\n    }\n  }\n\n  setCenter(coord) {\n    if (!Array.isArray(coord) || coord.length !== 2) {\n      throw new Error('Please provide a valid array with a lat/lon');\n    }\n\n    coord = coord.map(coord => parseFloat(coord));\n\n    this.state.moveAnimationStart = window.performance.now();\n    this.state.targetMoveOffset = coord;\n    this.state.targetMoveOffsetIsCoord = true;\n  }\n\n  setTargetMoveOffset(x, y, animated = true) {\n    if (animated) {\n      this.state.moveAnimationStart = window.performance.now();\n\n      this.state.targetMoveOffset = TileConversion.pixelToLatLon(\n        [x, y],\n        this.options.center,\n        this.options.zoom,\n        this.options.tileSize\n      );\n\n      this.state.targetMoveOffsetIsCoord = true;\n    } else {\n      this.state.targetMoveOffset = [x, y];\n      this.state.targetMoveOffsetIsCoord = false;\n\n      this.state.moveOffset = this.state.targetMoveOffset;\n    }\n  }\n\n  zoomValueIsValid(zoom) {\n    return zoom >= 1 && zoom <= 18;\n  }\n\n  isReadyForEvent() {\n    if (!this.state.lastEventActionTime) {\n      return true;\n    }\n\n    const now = window.performance.now();\n    const milliSecondsSinceLastEvent = now - this.state.lastEventActionTime;\n\n    return milliSecondsSinceLastEvent > this.options.debounceIntervalMs;\n  }\n\n  calculateVelocity(position1, position2, time1, time2) {\n    return ((position1 - position2) / (time1 - time2)) * 1000;\n  }\n\n  attachEvents() {\n    this.canvas.addEventListener('wheel', event => {\n      event.preventDefault();\n\n      if (this.isReadyForEvent()) {\n        if (event.deltaY > 5) {\n          this.setZoom(this.options.zoom - 1);\n        } else if (event.deltaY < -5) {\n          this.setZoom(this.options.zoom + 1);\n        }\n      }\n    });\n\n    this.canvas.addEventListener('dblclick', event => {\n      event.preventDefault();\n\n      const centerX = this.state.canvasDimensions[0] / 2;\n      const centerY = this.state.canvasDimensions[1] / 2;\n\n      this.setTargetMoveOffset(\n        -(event.clientX - centerX),\n        -(event.clientY - centerY)\n      );\n\n      this.setZoom(this.options.zoom + 1);\n    });\n\n    this.canvas.addEventListener('mousedown', event => {\n      event.preventDefault();\n\n      this.state.mouseVelocities = [];\n\n      this.state.dragStartPosition = [\n        event.clientX - this.state.moveOffset[0],\n        event.clientY - this.state.moveOffset[1]\n      ];\n    });\n\n    this.canvas.addEventListener('mouseup', event => {\n      event.preventDefault();\n\n      const x = -(this.state.dragStartPosition[0] - event.clientX);\n      const y = -(this.state.dragStartPosition[1] - event.clientY);\n\n      if (this.state.moveOffset[0] !== 0 || this.state.moveOffset[1] !== 0) {\n        const now = window.performance.now();\n        const timingThreshold = now - this.options.throwTimingThresholdMs;\n\n        const thresholdsToConsider = this.state.mouseVelocities\n          .filter(threshold => threshold[0] > timingThreshold)\n          .map(threshold => threshold[1]);\n\n        const velocitySum = thresholdsToConsider.reduce(\n          (accumulator, velocity) => accumulator + velocity,\n          0\n        );\n\n        const averageVelocity = velocitySum / thresholdsToConsider.length;\n\n        if (averageVelocity >= this.options.throwVelocityThreshold) {\n          let multiplier = averageVelocity / this.options.throwVelocityThreshold\n            * this.options.panAccelerationMultiplier;\n\n          multiplier = Math.min(multiplier, this.options.maxPanAcceleration);\n\n          this.setTargetMoveOffset(\n            x * multiplier,\n            y * multiplier\n          );\n        } else {\n          this.updateCenter();\n        }\n      }\n\n      this.state.dragStartPosition = null;\n    });\n\n    this.canvas.addEventListener('mousemove', event => {\n      event.preventDefault();\n\n      if (this.state.dragStartPosition) {\n        const x = -(this.state.dragStartPosition[0] - event.clientX);\n        const y = -(this.state.dragStartPosition[1] - event.clientY);\n\n        const now = window.performance.now();\n\n        const vx = this.calculateVelocity(this.state.moveOffset[0], x, now, this.state.lastMouseMoveEvent);\n        const vy = this.calculateVelocity(this.state.moveOffset[1], y, now, this.state.lastMouseMoveEvent);\n\n        const velocity = Math.round(Math.sqrt((vx * vx) + (vy * vy)));\n\n        this.state.mouseVelocities.push([now, velocity]);\n\n        this.setTargetMoveOffset(x, y, false);\n        this.state.lastMouseMoveEvent = window.performance.now();\n      }\n\n      return false;\n    });\n  }\n\n  applyStyles() {\n    this.canvas.style.cursor = 'grab';\n  }\n\n  easeOutQuad(time) {\n    return time * (2 - time);\n  }\n\n  updateMoveOffset() {\n    const targetMoveOffsetChanged = this.state.moveOffset !== this.state.targetMoveOffset;\n\n    if (targetMoveOffsetChanged) {\n      const timestamp = window.performance.now();\n\n      const progress = Math.max(timestamp - this.state.moveAnimationStart, 0);\n      const percentage = this.easeOutQuad(progress / this.options.animationDurationMs);\n\n      let targetMoveOffset = this.state.targetMoveOffset;\n\n      if (this.state.targetMoveOffsetIsCoord) {\n        targetMoveOffset = TileConversion.latLonToPixel(\n          this.state.targetMoveOffset,\n          this.options.center,\n          this.options.zoom,\n          this.options.tileSize,\n          this.state.canvasDimensions\n        );\n      }\n\n      if (percentage >= 0.99) {\n        this.state.moveOffset = targetMoveOffset;\n      } else {\n        this.state.moveOffset = [\n          this.state.moveOffset[0] + (targetMoveOffset[0] - this.state.moveOffset[0]) * percentage,\n          this.state.moveOffset[1] + (targetMoveOffset[1] - this.state.moveOffset[1]) * percentage\n        ];\n      }\n\n      const targetHasBeenReached = this.state.moveOffset === targetMoveOffset;\n\n      if (targetHasBeenReached) {\n        this.updateCenter();\n      }\n    }\n  }\n\n  updateCenter() {\n    const latLon = TileConversion.pixelToLatLon(\n      this.state.moveOffset,\n      this.options.center,\n      this.options.zoom,\n      this.options.tileSize\n    );\n\n    this.setTargetMoveOffset(0, 0, false);\n    this.options.center = latLon;\n  }\n\n  updateZoom() {\n    if (this.options.zoom !== this.state.targetZoom) {\n      const progress = Math.max(window.performance.now() - this.state.zoomAnimationStart, 0);\n      const percentage = this.easeOutQuad(progress / this.options.animationDurationMs);\n\n      let differenceFromTarget = Math.abs(this.state.targetZoom - this.state.startZoom);\n\n      if (this.state.targetZoom <= this.state.startZoom) {\n        differenceFromTarget *= -1;\n      }\n\n      const newZoomDiff = differenceFromTarget * percentage;\n      const remainingTime = this.options.animationDurationMs - progress;\n\n      this.options.zoom = remainingTime <= 5\n        ? this.state.targetZoom\n        : (this.state.startZoom + newZoomDiff);\n\n      const roundedZoom = Math.round(this.options.zoom);\n      const diff = this.options.zoom - roundedZoom;\n\n      this.state.scale = Math.pow(2, diff);\n\n      if (this.options.zoom === this.state.targetZoom) {\n        // Mark old tile layer for deletion\n        this.state.tileLayers.shift();\n        this.state.tileLayers[0].tilesZoomLevel = null;\n\n        // this.state.tileLayers[this.state.tileLayers.length - 1].shouldBeDeleted = true;\n      }\n    } else {\n      this.state.scale = 1;\n    }\n  }\n\n  garbageCollect() {\n    const allTiles = Object.values(this.state.tiles);\n\n    if (allTiles.length > this.maxTilesToKeep()) {\n      const tileExpirationCutOff = new Date().getTime() - 5000;\n\n      const tilesToConsider = allTiles\n        .filter(tile => tile.lastRequested < tileExpirationCutOff)\n        .sort((a, b) => ~~(a.lastRequested < b.lastRequested));\n\n      const tilesToDeleteCount = this.maxTilesToKeep() - (allTiles.length - tilesToConsider.length);\n\n      tilesToConsider\n        .splice(tilesToConsider.length - tilesToDeleteCount)\n        .forEach(tile => {\n          tile.src = '';\n          delete this.state.tiles[tile.tileId];\n        });\n    }\n  }\n\n  maxTilesToKeep() {\n    return 1000;\n  }\n\n  shouldRedraw() {\n    const drawState = JSON.stringify([this.state, this.options]);\n\n    if (this.lastDrawState !== drawState) {\n      this.lastDrawState = drawState;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  draw() {\n    this.updateMoveOffset();\n    this.updateZoom();\n    this.state.tileLayers.forEach(tileLayer => tileLayer.calculateGrid());\n    this.garbageCollect();\n\n    if (this.shouldRedraw()) {\n      // Delete tile layers that are ready for deletion and mostly loaded\n      /*\n      this.state.tileLayers = this.state.tileLayers\n        .filter(tileLayer => !(tileLayer.shouldBeDeleted && tileLayer.loadedPercentage() >= 0.9));\n\n      console.log(this.state.tileLayers.length);\n      */\n\n      if (this.state.tileLayers.length > 0) {\n        // Only draw the top layer\n        this.state.tileLayers[0].drawTiles(this.state.scale);\n      }\n\n      this.drawMarkers();\n      this.drawPolygons();\n      this.drawAttribution();\n    }\n\n    window.requestAnimationFrame(this.draw);\n  }\n\n  getMapBounds() {\n    const nw = TileConversion.pixelToLatLon(\n      [this.state.canvasDimensions[0] / 2, (this.state.canvasDimensions[1] / 2)],\n      this.options.center,\n      this.options.zoom,\n      this.options.tileSize\n    );\n\n    const se = TileConversion.pixelToLatLon(\n      [-this.state.canvasDimensions[0] / 2, -(this.state.canvasDimensions[1] / 2)],\n      this.options.center,\n      this.options.zoom,\n      this.options.tileSize\n    );\n\n    return {\n      nw, se\n    };\n  }\n\n  drawMarkers() {\n    const bounds = this.getMapBounds();\n\n    const visibleMarkers = this.state.markers.filter(marker => {\n      return marker.coords[0] <= bounds.nw[0] && marker.coords[0] >= bounds.se[0]\n        && marker.coords[1] >= bounds.nw[1] && marker.coords[1] <= bounds.se[1];\n    });\n\n    const center = [\n      this.state.canvasDimensions[0] / 2,\n      this.state.canvasDimensions[1] / 2\n    ];\n\n    visibleMarkers.map(marker => {\n      const position = TileConversion.latLonToPixel(\n        marker.coords,\n        this.options.center,\n        this.options.zoom,\n        this.options.tileSize,\n        this.state.canvasDimensions\n      );\n\n      marker.render(this.context, [\n        center[0] - position[0] + this.state.moveOffset[0],\n        center[1] - position[1] + this.state.moveOffset[1]\n      ]);\n    });\n  }\n\n  drawPolygons() {\n    const mapState = new MapState(\n      this.options.center,\n      this.options.zoom,\n      this.options.tileSize,\n      this.state.canvasDimensions,\n      this.state.moveOffset\n    );\n\n    this.state.polygons.map(polygon => {\n      polygon.render(this.context, mapState);\n    });\n  }\n\n  drawAttribution() {\n    const margin = 4;\n\n    this.context.font = 'bold 12px sans-serif';\n    const textBounds = this.context.measureText(this.options.attribution);\n\n    const x = this.state.canvasDimensions[0] - textBounds.width - margin;\n    const y = this.state.canvasDimensions[1] - 2 - margin;\n\n    this.context.fillStyle = 'rgba(255, 255, 255, 0.7)';\n    this.roundedRectangle(x - margin, y - 15, textBounds.width + 80, 80);\n\n    this.context.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.context.fillText(this.options.attribution, x, y);\n\n  }\n\n  roundedRectangle(x, y, width, height) {\n    const radius = 5;\n\n    this.context.beginPath();\n    this.context.moveTo(x + radius, y);\n    this.context.lineTo(x + width - radius, y);\n    this.context.quadraticCurveTo(x + width, y, x + width, y + radius);\n    this.context.lineTo(x + width, y + height - radius);\n    this.context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    this.context.lineTo(x + radius, y + height);\n    this.context.quadraticCurveTo(x, y + height, x, y + height - radius);\n    this.context.lineTo(x, y + radius);\n    this.context.quadraticCurveTo(x, y, x + radius, y);\n    this.context.closePath();\n\n    this.context.fill();\n  }\n\n  addMarker(marker) {\n    this.state.markers.push(marker);\n  }\n\n  addMarkers(markers) {\n    markers.map(marker => this.addMarker(marker));\n  }\n\n  addPolygon(polygon) {\n    this.state.polygons.push(polygon);\n  }\n\n}\n","import TileConversion from './TileConversion';\nimport Tile from './Tile';\n\nexport default class TileLayer {\n\n  constructor(map, tilesZoomLevel = null) {\n    this.map = map;\n    this.tilesZoomLevel = tilesZoomLevel;\n    this.shouldBeDeleted = false;\n\n    this.context = map.context;\n\n    this.state = {\n      grid: [],\n      gridHash: null,\n      relativeTileOffset: [0, 0]\n    };\n  }\n\n  toJSON() {\n    return [\n      this.state,\n      this.loadedPercentage() // We want a change in loaded tiles to possibly trigger a redraw\n    ];\n  }\n\n  getTilesCount(canvasSize) {\n    let tilesCount = Math.ceil(canvasSize / this.map.options.tileSize) * this.map.options.tileAreaMultiplier;\n\n    if (tilesCount % 2 === 0) {\n      tilesCount++;\n    }\n\n    return tilesCount;\n  }\n\n  calculateGrid() {\n    const { state, options } = this.map;\n\n    const centerY = TileConversion.lat2tile(options.center[0], Math.round(this.tilesZoomLevel || options.zoom), false);\n    const centerX = TileConversion.lon2tile(options.center[1], Math.round(this.tilesZoomLevel || options.zoom), false);\n    const gridHash = [centerY, centerX].join(',');\n\n    const gridNeedsToBeUpdated = this.state.gridHash !== gridHash;\n\n    if (!gridNeedsToBeUpdated) {\n      return;\n    }\n\n    const horizontalTiles = this.getTilesCount(state.canvasDimensions[0]);\n    const verticalTiles = this.getTilesCount(state.canvasDimensions[1]);\n\n    // noinspection JSSuspiciousNameCombination\n    const centerYRounded = Math.floor(centerY);\n    const centerXRounded = Math.floor(centerX);\n\n    this.state.relativeTileOffset = [\n      Math.abs(centerX - centerXRounded),\n      Math.abs(centerY - centerYRounded)\n    ];\n\n    const startX = centerXRounded - Math.floor(horizontalTiles / 2);\n    const startY = centerYRounded - Math.floor(verticalTiles / 2);\n\n    let grid = [];\n\n    for (let y = 0; y < verticalTiles; y++) {\n      for (let x = 0; x < horizontalTiles; x++) {\n        if (!grid[x]) {\n          grid[x] = [];\n        }\n\n        const tileX = startX + x;\n        const tileY = startY + y;\n\n        if (tileX >= 0 && tileY >= 0) {\n          grid[x][y] = new Tile(tileX, tileY, Math.round(this.tilesZoomLevel || options.zoom));\n          this.ensureTileAsset(grid[x][y]);\n        }\n      }\n    }\n\n    this.state.grid = grid;\n    this.state.gridHash = gridHash;\n  }\n\n  ensureTileAsset(tile) {\n    if (!(tile.id in this.map.state.tiles)) {\n      const tileUrl = this.map.options.source(Math.floor(tile.x), Math.floor(tile.y), tile.zoom);\n\n      this.map.state.tiles[tile.id] = new Image();\n      this.map.state.tiles[tile.id].tileId = tile.id;\n      this.map.state.tiles[tile.id].src = tileUrl;\n      this.map.state.tiles[tile.id].loaded = false;\n      this.map.state.tiles[tile.id].onload = () => {\n        this.map.state.tiles[tile.id].loaded = true;\n      };\n    }\n\n    this.map.state.tiles[tile.id].lastRequested = new Date().getTime();\n  }\n\n  drawTiles(scale) {\n    const canvasWidth = this.map.state.canvasDimensions[0];\n    const canvasHeight = this.map.state.canvasDimensions[1];\n\n    const tileSize = this.map.options.tileSize * scale;\n\n    const centerOffset = [\n      tileSize / 2 - (this.state.relativeTileOffset[0] * tileSize),\n      tileSize / 2 - (this.state.relativeTileOffset[1] * tileSize)\n    ];\n\n    this.context.fillStyle = '#EEE';\n    this.context.fillRect(0, 0, canvasWidth, canvasHeight);\n\n    const horizontalTiles = this.getTilesCount(canvasWidth);\n    const verticalTiles = this.getTilesCount(canvasHeight);\n\n    const horizontalOverflow = (horizontalTiles * tileSize) - canvasWidth;\n    const verticalOverflow = (verticalTiles * tileSize) - canvasHeight;\n\n    for (let y = 0; y < verticalTiles; y++) {\n      for (let x = 0; x < horizontalTiles; x++) {\n        const tile = this.state.grid[x][y];\n\n        if (tile) {\n          const tileX = this.map.state.moveOffset[0] + centerOffset[0]\n            + (x * tileSize - horizontalOverflow / 2);\n\n          const tileY = this.map.state.moveOffset[1] + centerOffset[1]\n            + (y * tileSize - verticalOverflow / 2);\n\n          try {\n            if (this.map.state.tiles[tile.id].loaded) {\n              this.context.drawImage(this.map.state.tiles[tile.id], tileX, tileY, tileSize, tileSize);\n            } else {\n              this.drawGenericBackground(tileX, tileY, tileSize);\n            }\n          } catch (err) {\n            this.drawGenericBackground(tileX, tileY, tileSize);\n          }\n\n          if (this.map.options.debug) {\n            this.context.strokeStyle = 'green';\n            this.context.strokeRect(tileX, tileY, tileSize, tileSize);\n          }\n        }\n      }\n    }\n\n    if (this.map.options.debug) {\n      this.context.fillStyle = 'rgba(200, 0, 0, 0.7)';\n      this.context.beginPath();\n      this.context.arc(canvasWidth / 2, canvasHeight / 2, 5, 0, 2 * Math.PI);\n      this.context.fill();\n    }\n  }\n\n  drawGenericBackground(x, y, size) {\n    const increment = size / 8;\n\n    this.context.beginPath();\n    for (let lineX = increment; lineX < size; lineX += increment) {\n      for (let lineY = increment; lineY < size; lineY += increment) {\n        this.context.moveTo(x, y + lineY);\n        this.context.lineTo(x + size, y + lineY);\n\n        this.context.moveTo(x + lineX, y);\n        this.context.lineTo(x + lineX, y + size);\n      }\n    }\n    this.context.strokeStyle = '#DDD';\n    this.context.stroke();\n\n    this.context.strokeStyle = '#CCC';\n    this.context.strokeRect(x, y, size, size);\n  }\n\n  loadedPercentage() {\n    const horizontalTiles = this.getTilesCount(this.map.state.canvasDimensions[0]);\n    const verticalTiles = this.getTilesCount(this.map.state.canvasDimensions[1]);\n\n    const totalTiles = horizontalTiles * verticalTiles;\n    let loadedTiles = 0;\n\n    for (let y = 0; y < verticalTiles; y++) {\n      for (let x = 0; x < horizontalTiles; x++) {\n        const tile = this.state.grid[x][y];\n\n        if (this.map.state.tiles[tile.id].loaded) {\n          loadedTiles++;\n        }\n      }\n    }\n\n    return loadedTiles / totalTiles;\n  }\n}\n","export default class Tile {\n  constructor(x, y, zoom) {\n    this._x = x;\n    this._y = y;\n    this._zoom = zoom;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  get zoom() {\n    return this._zoom;\n  }\n\n  get id() {\n    return [this.x, this.y, this.zoom].join('|');\n  }\n}\n","export default class MapState {\n  constructor(center, zoom, tileSize, canvasDimensions, moveOffset) {\n    this._center = center;\n    this._zoom = zoom;\n    this._tileSize = tileSize;\n    this._canvasDimensions = canvasDimensions;\n    this._moveOffset = moveOffset;\n  }\n\n  get center() {\n    return this._center;\n  }\n\n  get zoom() {\n    return this._zoom;\n  }\n\n  get tileSize() {\n    return this._tileSize;\n  }\n\n  get canvasDimensions() {\n    return this._canvasDimensions;\n  }\n\n  get moveOffset() {\n    return this._moveOffset;\n  }\n}\n","import { defaultMarkerOptions } from './defaultOptions';\n\nexport default class Marker {\n  constructor(coords, options = {}) {\n    this._coords = coords;\n    this._options = Object.assign({}, defaultMarkerOptions, options);\n  }\n\n  get coords() {\n    return this._coords;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  render(context, position) {\n    let renderFunction = null;\n\n    switch (this.options.type) {\n      case 'marker':\n        renderFunction = this.renderMarker;\n        break;\n\n      case 'circle':\n        renderFunction = this.renderCircle;\n        break;\n\n      case 'donut':\n        renderFunction = this.renderDonut;\n        break;\n    }\n\n    if (!renderFunction) {\n      throw new Error(`Unsupported marker type: \"${this.options.type}\"`);\n    } else {\n      context.fillStyle = this.options.color;\n      context.strokeStyle = this.options.color;\n\n      renderFunction = renderFunction.bind(this);\n      renderFunction(context, position);\n    }\n  }\n\n  renderCircle(context, position) {\n    context.save();\n    context.beginPath();\n    context.arc(position[0], position[1], 5, 0, 2 * Math.PI);\n    context.fill();\n    context.restore();\n  }\n\n  renderDonut(context, position) {\n    context.save();\n    context.beginPath();\n    context.lineWidth = 5;\n    context.arc(position[0], position[1], 7, 0, 2 * Math.PI);\n    context.stroke();\n    context.restore();\n  }\n\n  renderMarker(context, position) {\n    const markerWidth = 17.698069;\n    const markerHeight = 24.786272;\n\n    const x = position[0] - markerWidth / 2;\n    const y = position[1] - markerHeight;\n\n    context.save();\n    context.transform(0.184386, 0.000000, 0.000000, 0.184386, 0.551658 + x, 4.095760 + y);\n    context.beginPath();\n    context.lineWidth = 1.667195;\n    context.moveTo(45.000000, -22.212949);\n    context.bezierCurveTo(18.494941, -22.212949, -2.991863, -0.726145, -2.991863, 25.778914);\n    context.bezierCurveTo(-2.991863, 52.282306, 45.000000, 112.212950, 45.000000, 112.212950);\n    context.bezierCurveTo(45.000000, 112.212950, 92.991863, 52.282306, 92.991863, 25.777247);\n    context.bezierCurveTo(92.991863, -0.726145, 71.505059, -22.212949, 45.000000, -22.212949);\n    context.moveTo(45.000000, 43.827962);\n    context.bezierCurveTo(33.553042, 43.827962, 24.273437, 34.550024, 24.273437, 23.103067);\n    context.bezierCurveTo(24.273437, 11.656109, 33.553042, 2.376504, 45.000000, 2.376504);\n    context.bezierCurveTo(56.446958, 2.376504, 65.726563, 11.654442, 65.726563, 23.101399);\n    context.bezierCurveTo(65.726563, 34.548357, 56.446958, 43.827962, 45.000000, 43.827962);\n    context.fill();\n    context.restore();\n  }\n}\n","import { defaultPolygonOptions } from './defaultOptions';\nimport TileConversion from './TileConversion';\nimport { geoPath, geoTransform } from 'd3-geo';\nimport { mesh } from 'topojson-client';\n\nconst POLYGON_CACHE = {};\n\nexport default class Polygon {\n  constructor(sourceUrl, options = {}) {\n    this._sourceUrl = sourceUrl;\n    this._options = Object.assign({}, defaultPolygonOptions, options);\n    this._geometry = null;\n\n    fetch(this._sourceUrl)\n      .then(response => response.json())\n      .then(json => {\n        this._geometry = json;\n      })\n      .catch(err => console.log(`Could not load ${this._sourceUrl}: ${err.message || err}`));\n  }\n\n  get sourceUrl() {\n    return this._sourceUrl;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  render(context, mapState) {\n    if (!this._geometry) {\n      return;\n    }\n\n    context.fillStyle = this.options.color;\n    context.strokeStyle = this.options.color;\n\n    this.mapState = mapState;\n\n    const center = [\n      this.mapState.canvasDimensions[0] / 2,\n      this.mapState.canvasDimensions[1] / 2\n    ];\n\n    const transform = geoTransform({point: this.projectPoint, mapState, center });\n\n    const path = geoPath(transform).context(context);\n\n    context.beginPath();\n    path(mesh(this._geometry));\n    context.stroke();\n  }\n\n  projectPoint(x, y) {\n    const cachedPosition = (x, y, mapState) => {\n      const cacheKey = JSON.stringify([\n        [y, x], this.mapState.center, this.mapState.zoom,\n        this.mapState.tileSize, this.mapState.canvasDimensions\n      ]);\n\n      if (cacheKey in POLYGON_CACHE) {\n        return POLYGON_CACHE[cacheKey];\n      }\n\n      const position = TileConversion.latLonToPixel(\n        [y, x],\n        this.mapState.center,\n        this.mapState.zoom,\n        this.mapState.tileSize,\n        this.mapState.canvasDimensions\n      );\n\n      POLYGON_CACHE[cacheKey] = position;\n\n      return position;\n    };\n\n    const position = cachedPosition(x, y, this.mapState);\n\n    const projectedX = this.center[0] - position[0] + this.mapState.moveOffset[0];\n    const projectedY = this.center[1] - position[1] + this.mapState.moveOffset[1];\n\n    this.stream.point(projectedX, projectedY);\n  }\n}\n","// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nexport default function() {\n  return new Adder;\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add(temp, y, this.t);\n    add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n","export var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var tau = pi * 2;\n\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\n\nexport var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var ceil = Math.ceil;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var log = Math.log;\nexport var pow = Math.pow;\nexport var sin = Math.sin;\nexport var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nexport var sqrt = Math.sqrt;\nexport var tan = Math.tan;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nexport function haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n","export default function noop() {}\n","function streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nexport default function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n}\n","import adder from \"./adder\";\nimport {atan2, cos, quarterPi, radians, sin, tau} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nexport var areaRingSum = adder();\n\nvar areaSum = adder(),\n    lambda00,\n    phi00,\n    lambda0,\n    cosPhi0,\n    sinPhi0;\n\nexport var areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnolis\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nexport default function(object) {\n  areaSum.reset();\n  stream(object, areaStream);\n  return areaSum * 2;\n}\n","import {asin, atan2, cos, sin, sqrt} from \"./math\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n","import adder from \"./adder\";\nimport {areaStream, areaRingSum} from \"./area\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport {abs, degrees, epsilon, radians} from \"./math\";\nimport stream from \"./stream\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want\n// the distance between 180 to be 360.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n","import {asin, atan2, cos, degrees, epsilon, epsilon2, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  stream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export default function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n}\n","import compose from \"./compose\";\nimport {abs, asin, atan2, cos, degrees, pi, radians, sin, tau} from \"./math\";\n\nfunction rotationIdentity(lambda, phi) {\n  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nexport function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nexport default function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n","import {cartesian, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport constant from \"./constant\";\nimport {acos, cos, degrees, epsilon, radians, sin, tau} from \"./math\";\nimport {rotateRadians} from \"./rotation\";\n\n// Generates a circle centered at [0, 0], with a given radius and precision.\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nexport default function() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n","import noop from \"../noop\";\n\nexport default function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n","import {abs, epsilon} from \"./math\";\n\nexport default function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n","import pointEqual from \"../pointEqual\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n","import adder from \"./adder\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace} from \"./cartesian\";\nimport {asin, atan2, cos, epsilon, halfPi, pi, quarterPi, sin, tau} from \"./math\";\n\nvar sum = adder();\n\nexport default function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      sinPhi = sin(phi),\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum.reset();\n\n  if (sinPhi === 1) phi = halfPi + epsilon;\n  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the points meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n}\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","import {pair} from \"./pairs\";\n\nexport default function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n","export default function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","export default function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n","export default function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n}\n","import transpose from \"./transpose\";\n\nexport default function() {\n  return transpose(arguments);\n}\n","import clipBuffer from \"./buffer\";\nimport clipRejoin from \"./rejoin\";\nimport {epsilon, halfPi} from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n","import clip from \"./index\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n","import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\nimport {circleStream} from \"../circle\";\nimport {abs, cos, epsilon, pi, radians, sqrt} from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\n\nexport default function(radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n","export default function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n}\n","import {abs, epsilon} from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipRejoin from \"./rejoin\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygons polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n","import clipRectangle from \"./rectangle\";\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n","import adder from \"./adder\";\nimport {abs, atan2, cos, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar lengthSum = adder(),\n    lambda0,\n    sinPhi0,\n    cosPhi0;\n\nvar lengthStream = {\n  sphere: noop,\n  point: noop,\n  lineStart: lengthLineStart,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, sinPhi0 = sin(phi), cosPhi0 = cos(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin(phi),\n      cosPhi = cos(phi),\n      delta = abs(lambda - lambda0),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,\n      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;\n}\n\nexport default function(object) {\n  lengthSum.reset();\n  stream(object, lengthStream);\n  return +lengthSum;\n}\n","import length from \"./length\";\n\nvar coordinates = [null, null],\n    object = {type: \"LineString\", coordinates: coordinates};\n\nexport default function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length(object);\n}\n","import {default as polygonContains} from \"./polygonContains\";\nimport {default as distance} from \"./distance\";\nimport {epsilon, radians} from \"./math\";\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nexport default function(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n}\n","import {range} from \"d3-array\";\nimport {abs, ceil, epsilon} from \"./math\";\n\nfunction graticuleX(y0, y1, dy) {\n  var y = range(y0, y1 - epsilon, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = range(x0, x1 - epsilon, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nexport default function graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return range(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))\n        .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n}\n\nexport function graticule10() {\n  return graticule()();\n}\n","import {asin, atan2, cos, degrees, haversin, radians, sin, sqrt} from \"./math\";\n\nexport default function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos(y0),\n      sy0 = sin(y0),\n      cy1 = cos(y1),\n      sy1 = sin(y1),\n      kx0 = cy0 * cos(x0),\n      ky0 = cy0 * sin(x0),\n      kx1 = cy1 * cos(x1),\n      ky1 = cy1 * sin(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin(t *= d) / k,\n        A = sin(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees,\n      atan2(z, sqrt(x * x + y * y)) * degrees\n    ];\n  } : function() {\n    return [x0 * degrees, y0 * degrees];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n}\n","import adder from \"../adder\";\nimport {abs} from \"../math\";\nimport noop from \"../noop\";\n\nvar areaSum = adder(),\n    areaRingSum = adder(),\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;\n    areaSum.add(abs(areaRingSum));\n    areaRingSum.reset();\n  },\n  result: function() {\n    var area = areaSum / 2;\n    areaSum.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaPointFirst(x, y) {\n  areaStream.point = areaPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction areaPoint(x, y) {\n  areaRingSum.add(y0 * x - x0 * y);\n  x0 = x, y0 = y;\n}\n\nfunction areaRingEnd() {\n  areaPoint(x00, y00);\n}\n\nexport default areaStream;\n","export default function(x) {\n  return x;\n}\n","import noop from \"../noop\";\n\nvar x0 = Infinity,\n    y0 = x0,\n    x1 = -x0,\n    y1 = x1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function() {\n    var bounds = [[x0, y0], [x1, y1]];\n    x1 = y1 = -(y0 = x0 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint(x, y) {\n  if (x < x0) x0 = x;\n  if (x > x1) x1 = x;\n  if (y < y0) y0 = y;\n  if (y > y1) y1 = y;\n}\n\nexport default boundsStream;\n","import {sqrt} from \"../math\";\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0 = 0,\n    Y0 = 0,\n    Z0 = 0,\n    X1 = 0,\n    Y1 = 0,\n    Z1 = 0,\n    X2 = 0,\n    Y2 = 0,\n    Z2 = 0,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar centroidStream = {\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.point = centroidPoint;\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  },\n  result: function() {\n    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]\n        : Z1 ? [X1 / Z1, Y1 / Z1]\n        : Z0 ? [X0 / Z0, Y0 / Z0]\n        : [NaN, NaN];\n    X0 = Y0 = Z0 =\n    X1 = Y1 = Z1 =\n    X2 = Y2 = Z2 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint(x, y) {\n  X0 += x;\n  Y0 += y;\n  ++Z0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream.point = centroidPointLine;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0, dy = y - y0, z = sqrt(dx * dx + dy * dy);\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingStart() {\n  centroidStream.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd() {\n  centroidPointRing(x00, y00);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream.point = centroidPointRing;\n  centroidPoint(x00 = x0 = x, y00 = y0 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0,\n      dy = y - y0,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n\n  z = y0 * x - x0 * y;\n  X2 += z * (x0 + x);\n  Y2 += z * (y0 + y);\n  Z2 += z * 3;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nexport default centroidStream;\n","import {tau} from \"../math\";\nimport noop from \"../noop\";\n\nexport default function PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n","import adder from \"../adder\";\nimport {sqrt} from \"../math\";\nimport noop from \"../noop\";\n\nvar lengthSum = adder(),\n    lengthRing,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar lengthStream = {\n  point: noop,\n  lineStart: function() {\n    lengthStream.point = lengthPointFirst;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint(x00, y00);\n    lengthStream.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum;\n    lengthSum.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst(x, y) {\n  lengthStream.point = lengthPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction lengthPoint(x, y) {\n  x0 -= x, y0 -= y;\n  lengthSum.add(sqrt(x0 * x0 + y0 * y0));\n  x0 = x, y0 = y;\n}\n\nexport default lengthStream;\n","export default function PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n","import identity from \"../identity\";\nimport stream from \"../stream\";\nimport pathArea from \"./area\";\nimport pathBounds from \"./bounds\";\nimport pathCentroid from \"./centroid\";\nimport PathContext from \"./context\";\nimport pathMeasure from \"./measure\";\nimport PathString from \"./string\";\n\nexport default function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    stream(object, projectionStream(pathArea));\n    return pathArea.result();\n  };\n\n  path.measure = function(object) {\n    stream(object, projectionStream(pathMeasure));\n    return pathMeasure.result();\n  };\n\n  path.bounds = function(object) {\n    stream(object, projectionStream(pathBounds));\n    return pathBounds.result();\n  };\n\n  path.centroid = function(object) {\n    stream(object, projectionStream(pathCentroid));\n    return pathCentroid.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n}\n","export default function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nexport function transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n","import {default as geoStream} from \"../stream\";\nimport boundsStream from \"../path/bounds\";\n\nfunction fit(projection, fitBounds, object) {\n  var clip = projection.clipExtent && projection.clipExtent();\n  projection.scale(150).translate([0, 0]);\n  if (clip != null) projection.clipExtent(null);\n  geoStream(object, projection.stream(boundsStream));\n  fitBounds(boundsStream.result());\n  if (clip != null) projection.clipExtent(clip);\n  return projection;\n}\n\nexport function fitExtent(projection, extent, object) {\n  return fit(projection, function(b) {\n    var w = extent[1][0] - extent[0][0],\n        h = extent[1][1] - extent[0][1],\n        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nexport function fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nexport function fitWidth(projection, width, object) {\n  return fit(projection, function(b) {\n    var w = +width,\n        k = w / (b[1][0] - b[0][0]),\n        x = (w - k * (b[1][0] + b[0][0])) / 2,\n        y = -k * b[0][1];\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nexport function fitHeight(projection, height, object) {\n  return fit(projection, function(b) {\n    var h = +height,\n        k = h / (b[1][1] - b[0][1]),\n        x = -k * b[0][0],\n        y = (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n","import {cartesian} from \"../cartesian\";\nimport {abs, asin, atan2, cos, epsilon, radians, sqrt} from \"../math\";\nimport {transformer} from \"../transform\";\n\nvar maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nexport default function(project, delta2) {\n  return +delta2 ? resample(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n","import clipAntimeridian from \"../clip/antimeridian\";\nimport clipCircle from \"../clip/circle\";\nimport clipRectangle from \"../clip/rectangle\";\nimport compose from \"../compose\";\nimport identity from \"../identity\";\nimport {cos, degrees, radians, sin, sqrt} from \"../math\";\nimport {rotateRadians} from \"../rotation\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\nimport resample from \"./resample\";\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy) {\n  function transform(x, y) {\n    return [dx + k * x, dy - k * y];\n  }\n  transform.invert = function(x, y) {\n    return [(x - dx) / k, (dy - y) / k];\n  };\n  return transform;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, alpha) {\n  var cosAlpha = cos(alpha),\n      sinAlpha = sin(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform(x, y) {\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform.invert = function(x, y) {\n    return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n  };\n  return transform;\n}\n\nexport default function projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nexport function projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n      alpha = 0, // post-rotate\n      theta = null, preclip = clipAntimeridian, // pre-clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n      delta2 = 0.5, // precision\n      projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * radians, point[1] * radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function(_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  projection.fitWidth = function(width, object) {\n    return fitWidth(projection, width, object);\n  };\n\n  projection.fitHeight = function(height, object) {\n    return fitHeight(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),\n        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose(project, transform);\n    projectRotateTransform = compose(rotate, projectTransform);\n    projectResample = resample(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n","import {degrees, pi, radians} from \"../math\";\nimport {projectionMutator} from \"./index\";\n\nexport function conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n  };\n\n  return p;\n}\n","import {abs, asin, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {cylindricalEqualAreaRaw} from \"./cylindricalEqualArea\";\n\nexport function conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin(y)) / n;\n    return [r * sin(x *= n), r0 - r * cos(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n}\n","import {asin, cos, sin} from \"../math\";\n\nexport function cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n","import conicEqualArea from \"./conicEqualArea\";\n\nexport default function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n}\n","import {epsilon} from \"../math\";\nimport albers from \"./albers\";\nimport conicEqualArea from \"./conicEqualArea\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960500. The projection also works quite well at 960600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nexport default function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  albersUsa.fitWidth = function(width, object) {\n    return fitWidth(albersUsa, width, object);\n  };\n\n  albersUsa.fitHeight = function(height, object) {\n    return fitHeight(albersUsa, height, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n}\n","import {asin, atan2, cos, sin, sqrt} from \"../math\";\n\nexport function azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nexport function azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n","import {asin, sqrt} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nexport default function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n","import {acos, sin} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nexport default function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n","import {atan, exp, halfPi, log, pi, tan, tau} from \"../math\";\nimport rotation from \"../rotation\";\nimport projection from \"./index\";\n\nexport function mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nexport default function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nexport function mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n","import {abs, atan, atan2, cos, epsilon, halfPi, log, pow, sign, sin, sqrt, tan} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {mercatorRaw} from \"./mercator\";\n\nfunction tany(y) {\n  return tan((halfPi + y) / 2);\n}\n\nexport function conicConformalRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }\n    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }\n    var r = f / pow(tany(y), n);\n    return [r * sin(n * x), f - r * cos(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n}\n","import projection from \"./index\";\n\nexport function equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nexport default function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n","import {abs, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {equirectangularRaw} from \"./equirectangular\";\n\nexport function conicEquidistantRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin(nx), g - gy * cos(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n}\n","import projection from \"./index.js\";\nimport {abs, asin, cos, epsilon2, sin, sqrt} from \"../math.js\";\n\nvar A1 = 1.340264,\n    A2 = -0.081106,\n    A3 = 0.000893,\n    A4 = 0.003796,\n    M = sqrt(3) / 2,\n    iterations = 12;\n\nexport function equalEarthRaw(lambda, phi) {\n  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\n\nequalEarthRaw.invert = function(x, y) {\n  var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs(delta) < epsilon2) break;\n  }\n  return [\n    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n    asin(sin(l) / M)\n  ];\n};\n\nexport default function() {\n  return projection(equalEarthRaw)\n      .scale(177.158);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nexport default function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n","import clipRectangle from \"../clip/rectangle\";\nimport identity from \"../identity\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\n\nfunction scaleTranslate(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nexport default function() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n      x0 = null, y0, x1, y1, // clip extent\n      postclip = identity,\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));\n    },\n    postclip: function(_) {\n      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    },\n    fitWidth: function(width, object) {\n      return fitWidth(projection, width, object);\n    },\n    fitHeight: function(height, object) {\n      return fitHeight(projection, height, object);\n    }\n  };\n}\n","import projection from \"./index\";\nimport {abs, epsilon} from \"../math\";\n\nexport function naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nexport default function() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n","import {asin, cos, epsilon, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nexport default function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nexport default function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n","import {atan, exp, halfPi, log, tan} from \"../math\";\nimport {mercatorProjection} from \"./mercator\";\n\nexport function transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nexport default function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n","export {default as geoArea} from \"./area\";\nexport {default as geoBounds} from \"./bounds\";\nexport {default as geoCentroid} from \"./centroid\";\nexport {default as geoCircle} from \"./circle\";\nexport {default as geoClipAntimeridian} from \"./clip/antimeridian\";\nexport {default as geoClipCircle} from \"./clip/circle\";\nexport {default as geoClipExtent} from \"./clip/extent\"; // DEPRECATED! Use d3.geoIdentity().clipExtent().\nexport {default as geoClipRectangle} from \"./clip/rectangle\";\nexport {default as geoContains} from \"./contains\";\nexport {default as geoDistance} from \"./distance\";\nexport {default as geoGraticule, graticule10 as geoGraticule10} from \"./graticule\";\nexport {default as geoInterpolate} from \"./interpolate\";\nexport {default as geoLength} from \"./length\";\nexport {default as geoPath} from \"./path/index\";\nexport {default as geoAlbers} from \"./projection/albers\";\nexport {default as geoAlbersUsa} from \"./projection/albersUsa\";\nexport {default as geoAzimuthalEqualArea, azimuthalEqualAreaRaw as geoAzimuthalEqualAreaRaw} from \"./projection/azimuthalEqualArea\";\nexport {default as geoAzimuthalEquidistant, azimuthalEquidistantRaw as geoAzimuthalEquidistantRaw} from \"./projection/azimuthalEquidistant\";\nexport {default as geoConicConformal, conicConformalRaw as geoConicConformalRaw} from \"./projection/conicConformal\";\nexport {default as geoConicEqualArea, conicEqualAreaRaw as geoConicEqualAreaRaw} from \"./projection/conicEqualArea\";\nexport {default as geoConicEquidistant, conicEquidistantRaw as geoConicEquidistantRaw} from \"./projection/conicEquidistant\";\nexport {default as geoEqualEarth, equalEarthRaw as geoEqualEarthRaw} from \"./projection/equalEarth\";\nexport {default as geoEquirectangular, equirectangularRaw as geoEquirectangularRaw} from \"./projection/equirectangular\";\nexport {default as geoGnomonic, gnomonicRaw as geoGnomonicRaw} from \"./projection/gnomonic\";\nexport {default as geoIdentity} from \"./projection/identity\";\nexport {default as geoProjection, projectionMutator as geoProjectionMutator} from \"./projection/index\";\nexport {default as geoMercator, mercatorRaw as geoMercatorRaw} from \"./projection/mercator\";\nexport {default as geoNaturalEarth1, naturalEarth1Raw as geoNaturalEarth1Raw} from \"./projection/naturalEarth1\";\nexport {default as geoOrthographic, orthographicRaw as geoOrthographicRaw} from \"./projection/orthographic\";\nexport {default as geoStereographic, stereographicRaw as geoStereographicRaw} from \"./projection/stereographic\";\nexport {default as geoTransverseMercator, transverseMercatorRaw as geoTransverseMercatorRaw} from \"./projection/transverseMercator\";\nexport {default as geoRotation} from \"./rotation\";\nexport {default as geoStream} from \"./stream\";\nexport {default as geoTransform} from \"./transform\";\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import transform from \"./transform\";\n\nexport default function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","import bisect from \"./bisect\";\n\nexport default function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be 2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n","export {default as bbox} from \"./src/bbox\";\nexport {default as feature} from \"./src/feature\";\nexport {default as mesh, meshArcs} from \"./src/mesh\";\nexport {default as merge, mergeArcs} from \"./src/merge\";\nexport {default as neighbors} from \"./src/neighbors\";\nexport {default as quantize} from \"./src/quantize\";\nexport {default as transform} from \"./src/transform\";\nexport {default as untransform} from \"./src/untransform\";\n"],"sourceRoot":""}